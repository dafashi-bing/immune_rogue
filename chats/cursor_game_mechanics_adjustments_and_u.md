# Game mechanics adjustments and upgrades
_Exported on 9/26/2025 at 22:12:49 PDT from Cursor (1.6.45)_

---

**User**

- let's have damage multiplier for waves. I think the easiest way to do this is to configure it in waves.json and implement this in hero. So the more waves, the higher the damge it would take
- abilities seems to have no effect on phase 3 enemies
- previously, we have ability size to be upgrade by `extended reach`, let's move this to `enlarged caliber`. 
- also, let's have enlarged caliber to apply its configured value to both size increase (which was const 10%) and speed decrease

---

**Cursor**

I'll help you implement these changes. Let me first understand the current structure by examining the relevant files.

Now let me start implementing the changes. First, let me mark the first todo as in progress and add damage multiplier to waves configuration:

```yaml
wave_config:
  max_waves: 5
  wave_duration: 30.0

enemy_scaling:
  health_multiplier: 0.5
  spawn_speed_multiplier: 0
  damage_multiplier: 0.3
  description: Enemy health, spawn speed, and damage scale with wave progression. health_multiplier determines how much health increases per wave (0.5 = 50% per wave). spawn_speed_multiplier determines how much faster enemies spawn per wave (0 = no spawn speed scaling). damage_multiplier determines how much more damage enemies deal per wave (0.3 = 30% per wave).

shop_config:
  price_scaling:
    wave_multiplier: 0.7
    random_variance: 0.2
    roll_cost: 10
    description: Shop prices scale with wave progression. wave_multiplier determines how much prices increase per wave (0.5 = 50% per wave). random_variance adds Â±10% random price variation. roll_cost is the base cost to reroll shop items.

waves:
  - wave: 1
    name: First Contact
    description: Basic enemies to get you started
    enemy_types: [chaser]
    spawn_weights:
      chaser: 1.0
    spawn_interval: 2.5
    spawn_count: 2

  - wave: 2
    name: Ranged Assault
    description: Enemies that shoot from a distance
    enemy_types: [shooter]
    spawn_weights:
      shooter: 1.0
    spawn_interval: 2.0
    spawn_count: 2

  - wave: 3
    name: Mixed Forces
    description: A combination of enemy types
    enemy_types: [chaser, shooter]
    spawn_weights:
      chaser: 0.6
      shooter: 0.4
    spawn_interval: 1.8
    spawn_count: 3

  - wave: 4
    name: Heavy Assault
    description: More aggressive mixed enemies
    enemy_types: [chaser, shooter]
    spawn_weights:
      chaser: 0.5
      shooter: 0.5
    spawn_interval: 1.5
    spawn_count: 3

  - wave: 5
    name: Final Stand
    description: The ultimate challenge
    enemy_types: [chaser, shooter, shielded_chaser]
    spawn_weights:
      chaser: 0.35
      shooter: 0.55
      shielded_chaser: 0.1
    spawn_interval: 1.2
    spawn_count: 3

infinite_mode_spawns:
  description: Enemy types unlock at specific wave thresholds in infinite mode
  spawn_thresholds:
    swarmer: 6
    bomber: 8
    sniper: 10
    splitter: 12
    mine_layer: 14

```

Now I need to update the WaveConfig class to handle the damage multiplier:

```dart
import 'dart:convert';
import 'package:flutter/services.dart';
import 'package:yaml/yaml.dart';

class WaveSettings {
  final int maxWaves;
  final double waveDuration;
  
  WaveSettings({
    required this.maxWaves,
    required this.waveDuration,
  });
  
  factory WaveSettings.fromJson(Map<String, dynamic> json) {
    return WaveSettings(
      maxWaves: json['max_waves'],
      waveDuration: json['wave_duration'].toDouble(),
    );
  }
}

class ShopConfig {
  final double waveMultiplier;
  final double randomVariance;
  final int rollCost;
  final String description;
  
  ShopConfig({
    required this.waveMultiplier,
    required this.randomVariance,
    required this.rollCost,
    required this.description,
  });
  
  factory ShopConfig.fromJson(Map<String, dynamic> json) {
    final priceScaling = json['price_scaling'] ?? {};
    return ShopConfig(
      waveMultiplier: (priceScaling['wave_multiplier'] ?? 0.2).toDouble(),
      randomVariance: (priceScaling['random_variance'] ?? 0.05).toDouble(),
      rollCost: priceScaling['roll_cost'] ?? 10,
      description: priceScaling['description'] ?? '',
    );
  }
}

class WaveData {
  final int wave;
  final String name;
  final String description;
  final List<String> enemyTypes;
  final Map<String, double> spawnWeights;
  final double spawnInterval;
  final int spawnCount;
  
  WaveData({
    required this.wave,
    required this.name,
    required this.description,
    required this.enemyTypes,
    required this.spawnWeights,
    required this.spawnInterval,
    required this.spawnCount,
  });
  
  factory WaveData.fromJson(Map<String, dynamic> json) {
    return WaveData(
      wave: json['wave'],
      name: json['name'],
      description: json['description'],
      enemyTypes: List<String>.from(json['enemy_types']),
      spawnWeights: Map<String, double>.from(
        json['spawn_weights'].map((key, value) => MapEntry(key, value.toDouble()))
      ),
      spawnInterval: (json['spawn_interval'] ?? 2.0).toDouble(),
      spawnCount: json['spawn_count'] ?? 1,
    );
  }
}

class EnemyReward {
  final int coins;
  
  EnemyReward({required this.coins});
  
  factory EnemyReward.fromJson(Map<String, dynamic> json) {
    return EnemyReward(
      coins: json['coins'],
    );
  }
}

class EnemyData {
  final double movementSpeed;
  final double itemDropChance;
  final String description;
  
  EnemyData({
    required this.movementSpeed,
    required this.itemDropChance,
    required this.description,
  });
  
  factory EnemyData.fromJson(Map<String, dynamic> json) {
    return EnemyData(
      movementSpeed: (json['movement_speed'] ?? 50.0).toDouble(),
      itemDropChance: (json['item_drop_chance'] ?? 0.0).toDouble(),
      description: json['description'] ?? '',
    );
  }
}

class EnemyScaling {
  final double healthMultiplier;
  final double spawnSpeedMultiplier;
  final double damageMultiplier;
  final String description;
  
  EnemyScaling({
    required this.healthMultiplier,
    required this.spawnSpeedMultiplier,
    required this.damageMultiplier,
    required this.description,
  });
  
  factory EnemyScaling.fromJson(Map<String, dynamic> json) {
    return EnemyScaling(
      healthMultiplier: (json['health_multiplier'] ?? 0.0).toDouble(),
      spawnSpeedMultiplier: (json['spawn_speed_multiplier'] ?? 0.0).toDouble(),
      damageMultiplier: (json['damage_multiplier'] ?? 0.0).toDouble(),
      description: json['description'] ?? '',
    );
  }
}

class EnemyConfig {
  final Map<String, EnemyData> enemies;
  
  EnemyConfig({
    required this.enemies,
  });
  
  factory EnemyConfig.fromJson(Map<String, dynamic> json) {
    final Map<String, EnemyData> enemies = {};
    
    for (final entry in json.entries) {
      if (entry.value is Map<String, dynamic>) {
        enemies[entry.key] = EnemyData.fromJson(entry.value);
      }
    }
    
    return EnemyConfig(enemies: enemies);
  }
  
  double getMovementSpeed(String enemyType) {
    return enemies[enemyType]?.movementSpeed ?? 50.0; // Default fallback speed
  }
  
  double getRetryDropChance(String enemyType) {
    return enemies[enemyType]?.itemDropChance ?? 0.05; // Default fallback chance
  }
  
  EnemyData? getEnemyData(String enemyType) {
    return enemies[enemyType];
  }
}

class InfiniteSpawns {
  final Map<String, int> spawnThresholds;
  
  InfiniteSpawns({required this.spawnThresholds});
  
  factory InfiniteSpawns.fromJson(Map<String, dynamic> json) {
    final thresholds = json['spawn_thresholds'] as Map<String, dynamic>? ?? {};
    return InfiniteSpawns(
      spawnThresholds: thresholds.map((key, value) => MapEntry(key, value as int)),
    );
  }
  
  List<String> getAvailableEnemyTypes(int currentWave) {
    return spawnThresholds.entries
        .where((entry) => currentWave >= entry.value)
        .map((entry) => entry.key)
        .toList();
  }
}

class WaveConfig {
  static WaveConfig? _instance;
  static WaveConfig get instance => _instance ??= WaveConfig._();
  
  WaveConfig._();
  
  // Helper function to convert YAML maps to Map<String, dynamic>
  Map<String, dynamic> _convertYamlMap(Map yamlMap) {
    return yamlMap.map((key, value) {
      if (value is Map) {
        return MapEntry(key.toString(), _convertYamlMap(value));
      } else if (value is List) {
        return MapEntry(key.toString(), value.map((item) {
          if (item is Map) {
            return _convertYamlMap(item);
          }
          return item;
        }).toList());
      } else {
        return MapEntry(key.toString(), value);
      }
    });
  }
  
  WaveSettings? _settings;
  ShopConfig? _shopConfig;
  EnemyConfig? _enemyConfig;
  EnemyScaling? _enemyScaling;
  InfiniteSpawns? _infiniteSpawns;
  List<WaveData> _waves = [];
  Map<String, EnemyReward> _enemyRewards = {};
  bool _loaded = false;
  
  WaveSettings? get settings => _settings;
  ShopConfig? get shopConfig => _shopConfig;
  EnemyConfig? get enemyConfig => _enemyConfig;
  EnemyScaling? get enemyScaling => _enemyScaling;
  InfiniteSpawns? get infiniteSpawns => _infiniteSpawns;
  List<WaveData> get waves => _waves;
  Map<String, EnemyReward> get enemyRewards => _enemyRewards;
  
  Future<void> loadConfig() async {
    if (_loaded) return;
    
    try {
      final String yamlString = await rootBundle.loadString('assets/config/waves.yaml');
      final yamlData = loadYaml(yamlString) as Map;
      
      _settings = WaveSettings.fromJson(_convertYamlMap(yamlData['wave_config'] as Map));
      
      // Load shop configuration if available
      if (yamlData.containsKey('shop_config')) {
        _shopConfig = ShopConfig.fromJson(_convertYamlMap(yamlData['shop_config'] as Map));
      }
      
      // Enemy configuration is now loaded from enemies.yaml
      // No longer needed here
      
      // Load enemy scaling configuration if available
      if (yamlData.containsKey('enemy_scaling')) {
        _enemyScaling = EnemyScaling.fromJson(_convertYamlMap(yamlData['enemy_scaling'] as Map));
      }
      
      // Load infinite mode spawn configuration if available
      if (yamlData.containsKey('infinite_mode_spawns')) {
        _infiniteSpawns = InfiniteSpawns.fromJson(_convertYamlMap(yamlData['infinite_mode_spawns'] as Map));
      }
      
      _waves = (yamlData['waves'] as List)
          .map((wave) => WaveData.fromJson(_convertYamlMap(wave as Map)))
          .toList();
      
      // Load enemy rewards if available (for backward compatibility)
      if (yamlData.containsKey('enemy_rewards')) {
        _enemyRewards = (yamlData['enemy_rewards'] as Map)
            .map((key, value) => MapEntry(key.toString(), EnemyReward.fromJson(_convertYamlMap(value as Map))));
      } else {
        _enemyRewards = {}; // Empty map if no enemy rewards section
      }
      
      _loaded = true;
    } catch (e) {
      print('Error loading wave config: $e');
      // Fallback to default values if loading fails
      _settings = WaveSettings(
        maxWaves: 5,
        waveDuration: 30.0,
      );
      _shopConfig = ShopConfig(
        waveMultiplier: 0.2,
        randomVariance: 0.05,
        rollCost: 10,
        description: 'Default shop configuration',
      );
      _enemyConfig = EnemyConfig(
        enemies: {
          'chaser': EnemyData(movementSpeed: 50.0, itemDropChance: 0.0, description: ''),
          'shooter': EnemyData(movementSpeed: 80.0, itemDropChance: 0.0, description: ''),
          'shielded_chaser': EnemyData(movementSpeed: 60.0, itemDropChance: 0.0, description: ''),
        },
      );
      _waves = [];
      _enemyRewards = {};
      _loaded = true;
    }
  }
  
  WaveData? getWaveData(int waveNumber) {
    return _waves.where((wave) => wave.wave == waveNumber).firstOrNull;
  }
  
  EnemyReward? getEnemyReward(String enemyType) {
    return _enemyRewards[enemyType];
  }
  
  // Get spawn interval for a specific wave
  double getSpawnInterval(int waveNumber) {
    final waveData = getWaveData(waveNumber);
    return waveData?.spawnInterval ?? 2.0; // Default fallback
  }
  
  // Get spawn count for a specific wave
  int getSpawnCount(int waveNumber) {
    final waveData = getWaveData(waveNumber);
    return waveData?.spawnCount ?? 1; // Default fallback
  }
  
  // Calculate scaled health based on current wave
  double getScaledHealth(double baseHealth, int currentWave) {
    if (_enemyScaling == null || _enemyScaling!.healthMultiplier <= 0) {
      return baseHealth; // No scaling if config not available or multiplier is 0
    }
    
    // Apply scaling: baseHealth * (1 + healthMultiplier * (wave - 1))
    // Wave 1: no scaling, Wave 2: +50%, Wave 3: +100%, etc.
    final scalingFactor = 1.0 + (_enemyScaling!.healthMultiplier * (currentWave - 1));
    return baseHealth * scalingFactor;
  }
} 
```

Now I need to add a method to calculate scaled damage in the WaveConfig class:

```dart
import 'dart:convert';
import 'package:flutter/services.dart';
import 'package:yaml/yaml.dart';

class WaveSettings {
  final int maxWaves;
  final double waveDuration;
  
  WaveSettings({
    required this.maxWaves,
    required this.waveDuration,
  });
  
  factory WaveSettings.fromJson(Map<String, dynamic> json) {
    return WaveSettings(
      maxWaves: json['max_waves'],
      waveDuration: json['wave_duration'].toDouble(),
    );
  }
}

class ShopConfig {
  final double waveMultiplier;
  final double randomVariance;
  final int rollCost;
  final String description;
  
  ShopConfig({
    required this.waveMultiplier,
    required this.randomVariance,
    required this.rollCost,
    required this.description,
  });
  
  factory ShopConfig.fromJson(Map<String, dynamic> json) {
    final priceScaling = json['price_scaling'] ?? {};
    return ShopConfig(
      waveMultiplier: (priceScaling['wave_multiplier'] ?? 0.2).toDouble(),
      randomVariance: (priceScaling['random_variance'] ?? 0.05).toDouble(),
      rollCost: priceScaling['roll_cost'] ?? 10,
      description: priceScaling['description'] ?? '',
    );
  }
}

class WaveData {
  final int wave;
  final String name;
  final String description;
  final List<String> enemyTypes;
  final Map<String, double> spawnWeights;
  final double spawnInterval;
  final int spawnCount;
  
  WaveData({
    required this.wave,
    required this.name,
    required this.description,
    required this.enemyTypes,
    required this.spawnWeights,
    required this.spawnInterval,
    required this.spawnCount,
  });
  
  factory WaveData.fromJson(Map<String, dynamic> json) {
    return WaveData(
      wave: json['wave'],
      name: json['name'],
      description: json['description'],
      enemyTypes: List<String>.from(json['enemy_types']),
      spawnWeights: Map<String, double>.from(
        json['spawn_weights'].map((key, value) => MapEntry(key, value.toDouble()))
      ),
      spawnInterval: (json['spawn_interval'] ?? 2.0).toDouble(),
      spawnCount: json['spawn_count'] ?? 1,
    );
  }
}

class EnemyReward {
  final int coins;
  
  EnemyReward({required this.coins});
  
  factory EnemyReward.fromJson(Map<String, dynamic> json) {
    return EnemyReward(
      coins: json['coins'],
    );
  }
}

class EnemyData {
  final double movementSpeed;
  final double itemDropChance;
  final String description;
  
  EnemyData({
    required this.movementSpeed,
    required this.itemDropChance,
    required this.description,
  });
  
  factory EnemyData.fromJson(Map<String, dynamic> json) {
    return EnemyData(
      movementSpeed: (json['movement_speed'] ?? 50.0).toDouble(),
      itemDropChance: (json['item_drop_chance'] ?? 0.0).toDouble(),
      description: json['description'] ?? '',
    );
  }
}

class EnemyScaling {
  final double healthMultiplier;
  final double spawnSpeedMultiplier;
  final double damageMultiplier;
  final String description;
  
  EnemyScaling({
    required this.healthMultiplier,
    required this.spawnSpeedMultiplier,
    required this.damageMultiplier,
    required this.description,
  });
  
  factory EnemyScaling.fromJson(Map<String, dynamic> json) {
    return EnemyScaling(
      healthMultiplier: (json['health_multiplier'] ?? 0.0).toDouble(),
      spawnSpeedMultiplier: (json['spawn_speed_multiplier'] ?? 0.0).toDouble(),
      damageMultiplier: (json['damage_multiplier'] ?? 0.0).toDouble(),
      description: json['description'] ?? '',
    );
  }
}

class EnemyConfig {
  final Map<String, EnemyData> enemies;
  
  EnemyConfig({
    required this.enemies,
  });
  
  factory EnemyConfig.fromJson(Map<String, dynamic> json) {
    final Map<String, EnemyData> enemies = {};
    
    for (final entry in json.entries) {
      if (entry.value is Map<String, dynamic>) {
        enemies[entry.key] = EnemyData.fromJson(entry.value);
      }
    }
    
    return EnemyConfig(enemies: enemies);
  }
  
  double getMovementSpeed(String enemyType) {
    return enemies[enemyType]?.movementSpeed ?? 50.0; // Default fallback speed
  }
  
  double getRetryDropChance(String enemyType) {
    return enemies[enemyType]?.itemDropChance ?? 0.05; // Default fallback chance
  }
  
  EnemyData? getEnemyData(String enemyType) {
    return enemies[enemyType];
  }
}

class InfiniteSpawns {
  final Map<String, int> spawnThresholds;
  
  InfiniteSpawns({required this.spawnThresholds});
  
  factory InfiniteSpawns.fromJson(Map<String, dynamic> json) {
    final thresholds = json['spawn_thresholds'] as Map<String, dynamic>? ?? {};
    return InfiniteSpawns(
      spawnThresholds: thresholds.map((key, value) => MapEntry(key, value as int)),
    );
  }
  
  List<String> getAvailableEnemyTypes(int currentWave) {
    return spawnThresholds.entries
        .where((entry) => currentWave >= entry.value)
        .map((entry) => entry.key)
        .toList();
  }
}

class WaveConfig {
  static WaveConfig? _instance;
  static WaveConfig get instance => _instance ??= WaveConfig._();
  
  WaveConfig._();
  
  // Helper function to convert YAML maps to Map<String, dynamic>
  Map<String, dynamic> _convertYamlMap(Map yamlMap) {
    return yamlMap.map((key, value) {
      if (value is Map) {
        return MapEntry(key.toString(), _convertYamlMap(value));
      } else if (value is List) {
        return MapEntry(key.toString(), value.map((item) {
          if (item is Map) {
            return _convertYamlMap(item);
          }
          return item;
        }).toList());
      } else {
        return MapEntry(key.toString(), value);
      }
    });
  }
  
  WaveSettings? _settings;
  ShopConfig? _shopConfig;
  EnemyConfig? _enemyConfig;
  EnemyScaling? _enemyScaling;
  InfiniteSpawns? _infiniteSpawns;
  List<WaveData> _waves = [];
  Map<String, EnemyReward> _enemyRewards = {};
  bool _loaded = false;
  
  WaveSettings? get settings => _settings;
  ShopConfig? get shopConfig => _shopConfig;
  EnemyConfig? get enemyConfig => _enemyConfig;
  EnemyScaling? get enemyScaling => _enemyScaling;
  InfiniteSpawns? get infiniteSpawns => _infiniteSpawns;
  List<WaveData> get waves => _waves;
  Map<String, EnemyReward> get enemyRewards => _enemyRewards;
  
  Future<void> loadConfig() async {
    if (_loaded) return;
    
    try {
      final String yamlString = await rootBundle.loadString('assets/config/waves.yaml');
      final yamlData = loadYaml(yamlString) as Map;
      
      _settings = WaveSettings.fromJson(_convertYamlMap(yamlData['wave_config'] as Map));
      
      // Load shop configuration if available
      if (yamlData.containsKey('shop_config')) {
        _shopConfig = ShopConfig.fromJson(_convertYamlMap(yamlData['shop_config'] as Map));
      }
      
      // Enemy configuration is now loaded from enemies.yaml
      // No longer needed here
      
      // Load enemy scaling configuration if available
      if (yamlData.containsKey('enemy_scaling')) {
        _enemyScaling = EnemyScaling.fromJson(_convertYamlMap(yamlData['enemy_scaling'] as Map));
      }
      
      // Load infinite mode spawn configuration if available
      if (yamlData.containsKey('infinite_mode_spawns')) {
        _infiniteSpawns = InfiniteSpawns.fromJson(_convertYamlMap(yamlData['infinite_mode_spawns'] as Map));
      }
      
      _waves = (yamlData['waves'] as List)
          .map((wave) => WaveData.fromJson(_convertYamlMap(wave as Map)))
          .toList();
      
      // Load enemy rewards if available (for backward compatibility)
      if (yamlData.containsKey('enemy_rewards')) {
        _enemyRewards = (yamlData['enemy_rewards'] as Map)
            .map((key, value) => MapEntry(key.toString(), EnemyReward.fromJson(_convertYamlMap(value as Map))));
      } else {
        _enemyRewards = {}; // Empty map if no enemy rewards section
      }
      
      _loaded = true;
    } catch (e) {
      print('Error loading wave config: $e');
      // Fallback to default values if loading fails
      _settings = WaveSettings(
        maxWaves: 5,
        waveDuration: 30.0,
      );
      _shopConfig = ShopConfig(
        waveMultiplier: 0.2,
        randomVariance: 0.05,
        rollCost: 10,
        description: 'Default shop configuration',
      );
      _enemyConfig = EnemyConfig(
        enemies: {
          'chaser': EnemyData(movementSpeed: 50.0, itemDropChance: 0.0, description: ''),
          'shooter': EnemyData(movementSpeed: 80.0, itemDropChance: 0.0, description: ''),
          'shielded_chaser': EnemyData(movementSpeed: 60.0, itemDropChance: 0.0, description: ''),
        },
      );
      _waves = [];
      _enemyRewards = {};
      _loaded = true;
    }
  }
  
  WaveData? getWaveData(int waveNumber) {
    return _waves.where((wave) => wave.wave == waveNumber).firstOrNull;
  }
  
  EnemyReward? getEnemyReward(String enemyType) {
    return _enemyRewards[enemyType];
  }
  
  // Get spawn interval for a specific wave
  double getSpawnInterval(int waveNumber) {
    final waveData = getWaveData(waveNumber);
    return waveData?.spawnInterval ?? 2.0; // Default fallback
  }
  
  // Get spawn count for a specific wave
  int getSpawnCount(int waveNumber) {
    final waveData = getWaveData(waveNumber);
    return waveData?.spawnCount ?? 1; // Default fallback
  }
  
  // Calculate scaled health based on current wave
  double getScaledHealth(double baseHealth, int currentWave) {
    if (_enemyScaling == null || _enemyScaling!.healthMultiplier <= 0) {
      return baseHealth; // No scaling if config not available or multiplier is 0
    }
    
    // Apply scaling: baseHealth * (1 + healthMultiplier * (wave - 1))
    // Wave 1: no scaling, Wave 2: +50%, Wave 3: +100%, etc.
    final scalingFactor = 1.0 + (_enemyScaling!.healthMultiplier * (currentWave - 1));
    return baseHealth * scalingFactor;
  }
  
  // Calculate scaled damage based on current wave
  double getScaledDamage(double baseDamage, int currentWave) {
    if (_enemyScaling == null || _enemyScaling!.damageMultiplier <= 0) {
      return baseDamage; // No scaling if config not available or multiplier is 0
    }
    
    // Apply scaling: baseDamage * (1 + damageMultiplier * (wave - 1))
    // Wave 1: no scaling, Wave 2: +30%, Wave 3: +60%, etc.
    final scalingFactor = 1.0 + (_enemyScaling!.damageMultiplier * (currentWave - 1));
    return baseDamage * scalingFactor;
  }
} 
```

Now I need to implement the damage scaling in the hero's takeDamage method. Let me check how the game gets the current wave:

Perfect! I can see that `currentWave` is tracked as a property of the game. Now I need to update the hero's `takeDamage` method to use wave-scaled damage. Let me update the hero component:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Fallback for other enemy types - remove them directly
            if (enemy.parent != null) {
              gameRef.onEnemyDestroyed(enemy);
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and range scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: rangeMultiplier, // Scale with range upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range (now has range limitation)
    final effectiveRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: rangeMultiplier, // Scale with range multiplier
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final knockbackDistance = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get totalCharacterSize {
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get enlargedCaliberSpeedReduction {
    return getPassiveEffectStacks('enlarged_caliber') * 0.25;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

I need to add the import for WaveConfig:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Fallback for other enemy types - remove them directly
            if (enemy.parent != null) {
              gameRef.onEnemyDestroyed(enemy);
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and range scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: rangeMultiplier, // Scale with range upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range (now has range limitation)
    final effectiveRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: rangeMultiplier, // Scale with range multiplier
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final knockbackDistance = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get totalCharacterSize {
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get enlargedCaliberSpeedReduction {
    return getPassiveEffectStacks('enlarged_caliber') * 0.25;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

Now let me mark the first todo as complete and move to the second one:

Now let me investigate the phase 3 enemies issue. Let me first understand what enemies are in phase 3 and check if they have ability resistance:

I can see that wave 3 has both chasers and shooters. Let me check the ability implementation in the hero to see if there are issues with how abilities interact with enemies. Let me also check the specific enemy implementations:

I need to check if there are other enemy types that might be spawning in wave 3 that aren't handled by the ability system. Let me check if there are missing enemy types in the ability handling:

I can see that there are many enemy types (Swarmer, Bomber, Sniper, Splitter, MineLayer) that are not handled in the hero abilities. Let me check the specific ability methods to add support for all enemy types. Let me also check which enemy types have stun and takeDamage methods:

Let me check the bomber and mine_layer enemy takeDamage and stun methods:

Perfect! Now I can see that all enemy types (Bomber, MineLayer, Splitter, Swarmer, Sniper) have `takeDamage` and `stun` methods implemented. The issue is that the hero abilities only check for specific enemy types (EnemyChaser, EnemyShooter, ShieldedChaser) but don't handle the newer enemy types.

Let me update the hero abilities to handle all enemy types:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final takeDamageMethod = enemy.runtimeType.toString();
              if (takeDamageMethod.contains('Swarmer') || 
                  takeDamageMethod.contains('Bomber') || 
                  takeDamageMethod.contains('Sniper') || 
                  takeDamageMethod.contains('Splitter') || 
                  takeDamageMethod.contains('MineLayer')) {
                (enemy as dynamic).takeDamage(heroData.ability.damage);
              } else {
                // Fallback for unknown enemy types - remove them directly
                if (enemy.parent != null) {
                  gameRef.onEnemyDestroyed(enemy);
                }
              }
            } catch (e) {
              // If dynamic call fails, fallback to direct removal
              if (enemy.parent != null) {
                gameRef.onEnemyDestroyed(enemy);
              }
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and range scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: rangeMultiplier, // Scale with range upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range (now has range limitation)
    final effectiveRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: rangeMultiplier, // Scale with range multiplier
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final knockbackDistance = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get totalCharacterSize {
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get enlargedCaliberSpeedReduction {
    return getPassiveEffectStacks('enlarged_caliber') * 0.25;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

Now let me update the area stun ability to handle all enemy types:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final takeDamageMethod = enemy.runtimeType.toString();
              if (takeDamageMethod.contains('Swarmer') || 
                  takeDamageMethod.contains('Bomber') || 
                  takeDamageMethod.contains('Sniper') || 
                  takeDamageMethod.contains('Splitter') || 
                  takeDamageMethod.contains('MineLayer')) {
                (enemy as dynamic).takeDamage(heroData.ability.damage);
              } else {
                // Fallback for unknown enemy types - remove them directly
                if (enemy.parent != null) {
                  gameRef.onEnemyDestroyed(enemy);
                }
              }
            } catch (e) {
              // If dynamic call fails, fallback to direct removal
              if (enemy.parent != null) {
                gameRef.onEnemyDestroyed(enemy);
              }
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and range scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: rangeMultiplier, // Scale with range upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range (now has range limitation)
    final effectiveRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final enemyTypeName = enemy.runtimeType.toString();
              if (enemyTypeName.contains('Swarmer') || 
                  enemyTypeName.contains('Bomber') || 
                  enemyTypeName.contains('Sniper') || 
                  enemyTypeName.contains('Splitter') || 
                  enemyTypeName.contains('MineLayer')) {
                (enemy as dynamic).stun(stunDuration);
              }
            } catch (e) {
              // If dynamic call fails, ignore this enemy
              print('Failed to stun enemy: ${enemy.runtimeType}');
            }
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: rangeMultiplier, // Scale with range multiplier
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final knockbackDistance = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get totalCharacterSize {
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get enlargedCaliberSpeedReduction {
    return getPassiveEffectStacks('enlarged_caliber') * 0.25;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

Now let me update the resonance knockback ability to handle all enemy types:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final takeDamageMethod = enemy.runtimeType.toString();
              if (takeDamageMethod.contains('Swarmer') || 
                  takeDamageMethod.contains('Bomber') || 
                  takeDamageMethod.contains('Sniper') || 
                  takeDamageMethod.contains('Splitter') || 
                  takeDamageMethod.contains('MineLayer')) {
                (enemy as dynamic).takeDamage(heroData.ability.damage);
              } else {
                // Fallback for unknown enemy types - remove them directly
                if (enemy.parent != null) {
                  gameRef.onEnemyDestroyed(enemy);
                }
              }
            } catch (e) {
              // If dynamic call fails, fallback to direct removal
              if (enemy.parent != null) {
                gameRef.onEnemyDestroyed(enemy);
              }
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and range scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: rangeMultiplier, // Scale with range upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range (now has range limitation)
    final effectiveRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final enemyTypeName = enemy.runtimeType.toString();
              if (enemyTypeName.contains('Swarmer') || 
                  enemyTypeName.contains('Bomber') || 
                  enemyTypeName.contains('Sniper') || 
                  enemyTypeName.contains('Splitter') || 
                  enemyTypeName.contains('MineLayer')) {
                (enemy as dynamic).stun(stunDuration);
              }
            } catch (e) {
              // If dynamic call fails, ignore this enemy
              print('Failed to stun enemy: ${enemy.runtimeType}');
            }
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: rangeMultiplier, // Scale with range multiplier
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final knockbackDistance = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        } else {
          // Handle all other enemy types using reflection-like approach
          try {
            final enemyTypeName = enemy.runtimeType.toString();
            if (enemyTypeName.contains('Swarmer') || 
                enemyTypeName.contains('Bomber') || 
                enemyTypeName.contains('Sniper') || 
                enemyTypeName.contains('Splitter') || 
                enemyTypeName.contains('MineLayer')) {
              (enemy as dynamic).takeDamage(heroData.ability.damage);
            }
          } catch (e) {
            // If dynamic call fails, ignore this enemy
            print('Failed to damage enemy: ${enemy.runtimeType}');
          }
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get totalCharacterSize {
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get enlargedCaliberSpeedReduction {
    return getPassiveEffectStacks('enlarged_caliber') * 0.25;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

Let me also add the missing imports for the enemy types:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/swarmer.dart';
import 'enemies/bomber.dart';
import 'enemies/sniper.dart';
import 'enemies/splitter.dart';
import 'enemies/mine_layer.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final takeDamageMethod = enemy.runtimeType.toString();
              if (takeDamageMethod.contains('Swarmer') || 
                  takeDamageMethod.contains('Bomber') || 
                  takeDamageMethod.contains('Sniper') || 
                  takeDamageMethod.contains('Splitter') || 
                  takeDamageMethod.contains('MineLayer')) {
                (enemy as dynamic).takeDamage(heroData.ability.damage);
              } else {
                // Fallback for unknown enemy types - remove them directly
                if (enemy.parent != null) {
                  gameRef.onEnemyDestroyed(enemy);
                }
              }
            } catch (e) {
              // If dynamic call fails, fallback to direct removal
              if (enemy.parent != null) {
                gameRef.onEnemyDestroyed(enemy);
              }
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and range scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: rangeMultiplier, // Scale with range upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range (now has range limitation)
    final effectiveRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final enemyTypeName = enemy.runtimeType.toString();
              if (enemyTypeName.contains('Swarmer') || 
                  enemyTypeName.contains('Bomber') || 
                  enemyTypeName.contains('Sniper') || 
                  enemyTypeName.contains('Splitter') || 
                  enemyTypeName.contains('MineLayer')) {
                (enemy as dynamic).stun(stunDuration);
              }
            } catch (e) {
              // If dynamic call fails, ignore this enemy
              print('Failed to stun enemy: ${enemy.runtimeType}');
            }
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: rangeMultiplier, // Scale with range multiplier
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final knockbackDistance = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        } else {
          // Handle all other enemy types using reflection-like approach
          try {
            final enemyTypeName = enemy.runtimeType.toString();
            if (enemyTypeName.contains('Swarmer') || 
                enemyTypeName.contains('Bomber') || 
                enemyTypeName.contains('Sniper') || 
                enemyTypeName.contains('Splitter') || 
                enemyTypeName.contains('MineLayer')) {
              (enemy as dynamic).takeDamage(heroData.ability.damage);
            }
          } catch (e) {
            // If dynamic call fails, ignore this enemy
            print('Failed to damage enemy: ${enemy.runtimeType}');
          }
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get totalCharacterSize {
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get enlargedCaliberSpeedReduction {
    return getPassiveEffectStacks('enlarged_caliber') * 0.25;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

Now let me mark the second todo as complete and move to the third one:

Now I need to move the ability size upgrade from 'extended reach' to 'enlarged caliber'. Let me first check how extended reach currently works:

I can see that `rangeMultiplier` is used in several places for abilities. Let me search for how abilities use the range multiplier:

I can see that `rangeMultiplier` is used for ability ranges, but I need to find where ability size is affected. Let me check the triangle projectile and shape projectile for size scaling:

Found it! In the radial burst ability, `sizeScale` is set to `rangeMultiplier`. Let me also check the triangle projectile:

Perfect! Now I can see that the `rangeMultiplier` affects:
1. Triangle projectile size (via `rangeMultiplier` parameter)
2. Radial burst projectile size (via `sizeScale: rangeMultiplier`)

I need to change these to use a new ability size multiplier based on `enlarged_caliber` instead of `rangeMultiplier`. Let me first add a new getter for ability size multiplier:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/swarmer.dart';
import 'enemies/bomber.dart';
import 'enemies/sniper.dart';
import 'enemies/splitter.dart';
import 'enemies/mine_layer.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final takeDamageMethod = enemy.runtimeType.toString();
              if (takeDamageMethod.contains('Swarmer') || 
                  takeDamageMethod.contains('Bomber') || 
                  takeDamageMethod.contains('Sniper') || 
                  takeDamageMethod.contains('Splitter') || 
                  takeDamageMethod.contains('MineLayer')) {
                (enemy as dynamic).takeDamage(heroData.ability.damage);
              } else {
                // Fallback for unknown enemy types - remove them directly
                if (enemy.parent != null) {
                  gameRef.onEnemyDestroyed(enemy);
                }
              }
            } catch (e) {
              // If dynamic call fails, fallback to direct removal
              if (enemy.parent != null) {
                gameRef.onEnemyDestroyed(enemy);
              }
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and range scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: rangeMultiplier, // Scale with range upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range (now has range limitation)
    final effectiveRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final enemyTypeName = enemy.runtimeType.toString();
              if (enemyTypeName.contains('Swarmer') || 
                  enemyTypeName.contains('Bomber') || 
                  enemyTypeName.contains('Sniper') || 
                  enemyTypeName.contains('Splitter') || 
                  enemyTypeName.contains('MineLayer')) {
                (enemy as dynamic).stun(stunDuration);
              }
            } catch (e) {
              // If dynamic call fails, ignore this enemy
              print('Failed to stun enemy: ${enemy.runtimeType}');
            }
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: rangeMultiplier, // Scale with range multiplier
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final knockbackDistance = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        } else {
          // Handle all other enemy types using reflection-like approach
          try {
            final enemyTypeName = enemy.runtimeType.toString();
            if (enemyTypeName.contains('Swarmer') || 
                enemyTypeName.contains('Bomber') || 
                enemyTypeName.contains('Sniper') || 
                enemyTypeName.contains('Splitter') || 
                enemyTypeName.contains('MineLayer')) {
              (enemy as dynamic).takeDamage(heroData.ability.damage);
            }
          } catch (e) {
            // If dynamic call fails, ignore this enemy
            print('Failed to damage enemy: ${enemy.runtimeType}');
          }
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get totalAbilitySize {
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * 0.25);
  }
  
  double get totalCharacterSize {
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get enlargedCaliberSpeedReduction {
    return getPassiveEffectStacks('enlarged_caliber') * 0.25;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

Now let me update the triangle projectile to use the ability size multiplier instead of range multiplier:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/swarmer.dart';
import 'enemies/bomber.dart';
import 'enemies/sniper.dart';
import 'enemies/splitter.dart';
import 'enemies/mine_layer.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final takeDamageMethod = enemy.runtimeType.toString();
              if (takeDamageMethod.contains('Swarmer') || 
                  takeDamageMethod.contains('Bomber') || 
                  takeDamageMethod.contains('Sniper') || 
                  takeDamageMethod.contains('Splitter') || 
                  takeDamageMethod.contains('MineLayer')) {
                (enemy as dynamic).takeDamage(heroData.ability.damage);
              } else {
                // Fallback for unknown enemy types - remove them directly
                if (enemy.parent != null) {
                  gameRef.onEnemyDestroyed(enemy);
                }
              }
            } catch (e) {
              // If dynamic call fails, fallback to direct removal
              if (enemy.parent != null) {
                gameRef.onEnemyDestroyed(enemy);
              }
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and ability size scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: totalAbilitySize, // Scale with enlarged caliber upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range (now has range limitation)
    final effectiveRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final enemyTypeName = enemy.runtimeType.toString();
              if (enemyTypeName.contains('Swarmer') || 
                  enemyTypeName.contains('Bomber') || 
                  enemyTypeName.contains('Sniper') || 
                  enemyTypeName.contains('Splitter') || 
                  enemyTypeName.contains('MineLayer')) {
                (enemy as dynamic).stun(stunDuration);
              }
            } catch (e) {
              // If dynamic call fails, ignore this enemy
              print('Failed to stun enemy: ${enemy.runtimeType}');
            }
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: rangeMultiplier, // Scale with range multiplier
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final knockbackDistance = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        } else {
          // Handle all other enemy types using reflection-like approach
          try {
            final enemyTypeName = enemy.runtimeType.toString();
            if (enemyTypeName.contains('Swarmer') || 
                enemyTypeName.contains('Bomber') || 
                enemyTypeName.contains('Sniper') || 
                enemyTypeName.contains('Splitter') || 
                enemyTypeName.contains('MineLayer')) {
              (enemy as dynamic).takeDamage(heroData.ability.damage);
            }
          } catch (e) {
            // If dynamic call fails, ignore this enemy
            print('Failed to damage enemy: ${enemy.runtimeType}');
          }
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get totalAbilitySize {
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * 0.25);
  }
  
  double get totalCharacterSize {
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get enlargedCaliberSpeedReduction {
    return getPassiveEffectStacks('enlarged_caliber') * 0.25;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

Now let me update the radial burst projectiles to use the ability size multiplier:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/swarmer.dart';
import 'enemies/bomber.dart';
import 'enemies/sniper.dart';
import 'enemies/splitter.dart';
import 'enemies/mine_layer.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final takeDamageMethod = enemy.runtimeType.toString();
              if (takeDamageMethod.contains('Swarmer') || 
                  takeDamageMethod.contains('Bomber') || 
                  takeDamageMethod.contains('Sniper') || 
                  takeDamageMethod.contains('Splitter') || 
                  takeDamageMethod.contains('MineLayer')) {
                (enemy as dynamic).takeDamage(heroData.ability.damage);
              } else {
                // Fallback for unknown enemy types - remove them directly
                if (enemy.parent != null) {
                  gameRef.onEnemyDestroyed(enemy);
                }
              }
            } catch (e) {
              // If dynamic call fails, fallback to direct removal
              if (enemy.parent != null) {
                gameRef.onEnemyDestroyed(enemy);
              }
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and ability size scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: totalAbilitySize, // Scale with enlarged caliber upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range (now has range limitation)
    final effectiveRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final enemyTypeName = enemy.runtimeType.toString();
              if (enemyTypeName.contains('Swarmer') || 
                  enemyTypeName.contains('Bomber') || 
                  enemyTypeName.contains('Sniper') || 
                  enemyTypeName.contains('Splitter') || 
                  enemyTypeName.contains('MineLayer')) {
                (enemy as dynamic).stun(stunDuration);
              }
            } catch (e) {
              // If dynamic call fails, ignore this enemy
              print('Failed to stun enemy: ${enemy.runtimeType}');
            }
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: totalAbilitySize, // Scale with enlarged caliber
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final knockbackDistance = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        } else {
          // Handle all other enemy types using reflection-like approach
          try {
            final enemyTypeName = enemy.runtimeType.toString();
            if (enemyTypeName.contains('Swarmer') || 
                enemyTypeName.contains('Bomber') || 
                enemyTypeName.contains('Sniper') || 
                enemyTypeName.contains('Splitter') || 
                enemyTypeName.contains('MineLayer')) {
              (enemy as dynamic).takeDamage(heroData.ability.damage);
            }
          } catch (e) {
            // If dynamic call fails, ignore this enemy
            print('Failed to damage enemy: ${enemy.runtimeType}');
          }
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get totalAbilitySize {
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * 0.25);
  }
  
  double get totalCharacterSize {
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get enlargedCaliberSpeedReduction {
    return getPassiveEffectStacks('enlarged_caliber') * 0.25;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

Now let me mark the third todo as complete and move to the fourth one:

Now I need to configure enlarged caliber to apply both size increase and speed decrease with its configured value. Looking at the items.yaml, I can see that enlarged caliber has a value of 0.25 (25%). Let me update the hero's calculations to use this configured value consistently.

First, let me check the current items.yaml configuration:

Perfect! The configured value is 0.25 (25%). Now I need to update the hero's calculations to use this configured value. Currently, the calculations are hardcoded. Let me find where the enlarged caliber effects are calculated and make them use the configured value.

First, let me check how item effects are applied. I need to find where the value from the item config is used:

I can see that the `addPassiveEffect` method only tracks stacks, not the configured values from items. The problem is that the hero's calculations are hardcoded with specific values instead of using the item's configured value. 

I need to access the item configuration to get the actual value (0.25) and use it in the calculations. Let me check how to access item config:

Perfect! I can use `ItemConfig.instance.getItemById('enlarged_caliber')` to get the configured value. Let me update the hero's enlarged caliber calculations to use the configured value instead of hardcoded ones:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import '../config/item_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/swarmer.dart';
import 'enemies/bomber.dart';
import 'enemies/sniper.dart';
import 'enemies/splitter.dart';
import 'enemies/mine_layer.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final takeDamageMethod = enemy.runtimeType.toString();
              if (takeDamageMethod.contains('Swarmer') || 
                  takeDamageMethod.contains('Bomber') || 
                  takeDamageMethod.contains('Sniper') || 
                  takeDamageMethod.contains('Splitter') || 
                  takeDamageMethod.contains('MineLayer')) {
                (enemy as dynamic).takeDamage(heroData.ability.damage);
              } else {
                // Fallback for unknown enemy types - remove them directly
                if (enemy.parent != null) {
                  gameRef.onEnemyDestroyed(enemy);
                }
              }
            } catch (e) {
              // If dynamic call fails, fallback to direct removal
              if (enemy.parent != null) {
                gameRef.onEnemyDestroyed(enemy);
              }
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and ability size scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: totalAbilitySize, // Scale with enlarged caliber upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range (now has range limitation)
    final effectiveRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final enemyTypeName = enemy.runtimeType.toString();
              if (enemyTypeName.contains('Swarmer') || 
                  enemyTypeName.contains('Bomber') || 
                  enemyTypeName.contains('Sniper') || 
                  enemyTypeName.contains('Splitter') || 
                  enemyTypeName.contains('MineLayer')) {
                (enemy as dynamic).stun(stunDuration);
              }
            } catch (e) {
              // If dynamic call fails, ignore this enemy
              print('Failed to stun enemy: ${enemy.runtimeType}');
            }
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: totalAbilitySize, // Scale with enlarged caliber
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final knockbackDistance = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        } else {
          // Handle all other enemy types using reflection-like approach
          try {
            final enemyTypeName = enemy.runtimeType.toString();
            if (enemyTypeName.contains('Swarmer') || 
                enemyTypeName.contains('Bomber') || 
                enemyTypeName.contains('Sniper') || 
                enemyTypeName.contains('Splitter') || 
                enemyTypeName.contains('MineLayer')) {
              (enemy as dynamic).takeDamage(heroData.ability.damage);
            }
          } catch (e) {
            // If dynamic call fails, ignore this enemy
            print('Failed to damage enemy: ${enemy.runtimeType}');
          }
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get totalAbilitySize {
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * 0.25);
  }
  
  double get totalCharacterSize {
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * 0.1);
  }
  
  double get enlargedCaliberSpeedReduction {
    return getPassiveEffectStacks('enlarged_caliber') * 0.25;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

Now let me update the enlarged caliber calculations to use the configured value:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import '../config/item_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/swarmer.dart';
import 'enemies/bomber.dart';
import 'enemies/sniper.dart';
import 'enemies/splitter.dart';
import 'enemies/mine_layer.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final takeDamageMethod = enemy.runtimeType.toString();
              if (takeDamageMethod.contains('Swarmer') || 
                  takeDamageMethod.contains('Bomber') || 
                  takeDamageMethod.contains('Sniper') || 
                  takeDamageMethod.contains('Splitter') || 
                  takeDamageMethod.contains('MineLayer')) {
                (enemy as dynamic).takeDamage(heroData.ability.damage);
              } else {
                // Fallback for unknown enemy types - remove them directly
                if (enemy.parent != null) {
                  gameRef.onEnemyDestroyed(enemy);
                }
              }
            } catch (e) {
              // If dynamic call fails, fallback to direct removal
              if (enemy.parent != null) {
                gameRef.onEnemyDestroyed(enemy);
              }
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and ability size scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: totalAbilitySize, // Scale with enlarged caliber upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range (now has range limitation)
    final effectiveRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final enemyTypeName = enemy.runtimeType.toString();
              if (enemyTypeName.contains('Swarmer') || 
                  enemyTypeName.contains('Bomber') || 
                  enemyTypeName.contains('Sniper') || 
                  enemyTypeName.contains('Splitter') || 
                  enemyTypeName.contains('MineLayer')) {
                (enemy as dynamic).stun(stunDuration);
              }
            } catch (e) {
              // If dynamic call fails, ignore this enemy
              print('Failed to stun enemy: ${enemy.runtimeType}');
            }
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: totalAbilitySize, // Scale with enlarged caliber
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final knockbackDistance = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        } else {
          // Handle all other enemy types using reflection-like approach
          try {
            final enemyTypeName = enemy.runtimeType.toString();
            if (enemyTypeName.contains('Swarmer') || 
                enemyTypeName.contains('Bomber') || 
                enemyTypeName.contains('Sniper') || 
                enemyTypeName.contains('Splitter') || 
                enemyTypeName.contains('MineLayer')) {
              (enemy as dynamic).takeDamage(heroData.ability.damage);
            }
          } catch (e) {
            // If dynamic call fails, ignore this enemy
            print('Failed to damage enemy: ${enemy.runtimeType}');
          }
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get totalAbilitySize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get totalCharacterSize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get enlargedCaliberSpeedReduction {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

Perfect! Now let me mark the final todo as completed:

Now let me check for any linter errors in the files I've modified:

Let me fix these linter errors by removing the unused imports:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import '../config/item_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final takeDamageMethod = enemy.runtimeType.toString();
              if (takeDamageMethod.contains('Swarmer') || 
                  takeDamageMethod.contains('Bomber') || 
                  takeDamageMethod.contains('Sniper') || 
                  takeDamageMethod.contains('Splitter') || 
                  takeDamageMethod.contains('MineLayer')) {
                (enemy as dynamic).takeDamage(heroData.ability.damage);
              } else {
                // Fallback for unknown enemy types - remove them directly
                if (enemy.parent != null) {
                  gameRef.onEnemyDestroyed(enemy);
                }
              }
            } catch (e) {
              // If dynamic call fails, fallback to direct removal
              if (enemy.parent != null) {
                gameRef.onEnemyDestroyed(enemy);
              }
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and ability size scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: totalAbilitySize, // Scale with enlarged caliber upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range (now has range limitation)
    final effectiveRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final enemyTypeName = enemy.runtimeType.toString();
              if (enemyTypeName.contains('Swarmer') || 
                  enemyTypeName.contains('Bomber') || 
                  enemyTypeName.contains('Sniper') || 
                  enemyTypeName.contains('Splitter') || 
                  enemyTypeName.contains('MineLayer')) {
                (enemy as dynamic).stun(stunDuration);
              }
            } catch (e) {
              // If dynamic call fails, ignore this enemy
              print('Failed to stun enemy: ${enemy.runtimeType}');
            }
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: totalAbilitySize, // Scale with enlarged caliber
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final knockbackDistance = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        } else {
          // Handle all other enemy types using reflection-like approach
          try {
            final enemyTypeName = enemy.runtimeType.toString();
            if (enemyTypeName.contains('Swarmer') || 
                enemyTypeName.contains('Bomber') || 
                enemyTypeName.contains('Sniper') || 
                enemyTypeName.contains('Splitter') || 
                enemyTypeName.contains('MineLayer')) {
              (enemy as dynamic).takeDamage(heroData.ability.damage);
            }
          } catch (e) {
            // If dynamic call fails, ignore this enemy
            print('Failed to damage enemy: ${enemy.runtimeType}');
          }
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get totalAbilitySize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get totalCharacterSize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get enlargedCaliberSpeedReduction {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

```dart
import 'package:flutter/services.dart';
import 'package:yaml/yaml.dart';

class WaveSettings {
  final int maxWaves;
  final double waveDuration;
  
  WaveSettings({
    required this.maxWaves,
    required this.waveDuration,
  });
  
  factory WaveSettings.fromJson(Map<String, dynamic> json) {
    return WaveSettings(
      maxWaves: json['max_waves'],
      waveDuration: json['wave_duration'].toDouble(),
    );
  }
}

class ShopConfig {
  final double waveMultiplier;
  final double randomVariance;
  final int rollCost;
  final String description;
  
  ShopConfig({
    required this.waveMultiplier,
    required this.randomVariance,
    required this.rollCost,
    required this.description,
  });
  
  factory ShopConfig.fromJson(Map<String, dynamic> json) {
    final priceScaling = json['price_scaling'] ?? {};
    return ShopConfig(
      waveMultiplier: (priceScaling['wave_multiplier'] ?? 0.2).toDouble(),
      randomVariance: (priceScaling['random_variance'] ?? 0.05).toDouble(),
      rollCost: priceScaling['roll_cost'] ?? 10,
      description: priceScaling['description'] ?? '',
    );
  }
}

class WaveData {
  final int wave;
  final String name;
  final String description;
  final List<String> enemyTypes;
  final Map<String, double> spawnWeights;
  final double spawnInterval;
  final int spawnCount;
  
  WaveData({
    required this.wave,
    required this.name,
    required this.description,
    required this.enemyTypes,
    required this.spawnWeights,
    required this.spawnInterval,
    required this.spawnCount,
  });
  
  factory WaveData.fromJson(Map<String, dynamic> json) {
    return WaveData(
      wave: json['wave'],
      name: json['name'],
      description: json['description'],
      enemyTypes: List<String>.from(json['enemy_types']),
      spawnWeights: Map<String, double>.from(
        json['spawn_weights'].map((key, value) => MapEntry(key, value.toDouble()))
      ),
      spawnInterval: (json['spawn_interval'] ?? 2.0).toDouble(),
      spawnCount: json['spawn_count'] ?? 1,
    );
  }
}

class EnemyReward {
  final int coins;
  
  EnemyReward({required this.coins});
  
  factory EnemyReward.fromJson(Map<String, dynamic> json) {
    return EnemyReward(
      coins: json['coins'],
    );
  }
}

class EnemyData {
  final double movementSpeed;
  final double itemDropChance;
  final String description;
  
  EnemyData({
    required this.movementSpeed,
    required this.itemDropChance,
    required this.description,
  });
  
  factory EnemyData.fromJson(Map<String, dynamic> json) {
    return EnemyData(
      movementSpeed: (json['movement_speed'] ?? 50.0).toDouble(),
      itemDropChance: (json['item_drop_chance'] ?? 0.0).toDouble(),
      description: json['description'] ?? '',
    );
  }
}

class EnemyScaling {
  final double healthMultiplier;
  final double spawnSpeedMultiplier;
  final double damageMultiplier;
  final String description;
  
  EnemyScaling({
    required this.healthMultiplier,
    required this.spawnSpeedMultiplier,
    required this.damageMultiplier,
    required this.description,
  });
  
  factory EnemyScaling.fromJson(Map<String, dynamic> json) {
    return EnemyScaling(
      healthMultiplier: (json['health_multiplier'] ?? 0.0).toDouble(),
      spawnSpeedMultiplier: (json['spawn_speed_multiplier'] ?? 0.0).toDouble(),
      damageMultiplier: (json['damage_multiplier'] ?? 0.0).toDouble(),
      description: json['description'] ?? '',
    );
  }
}

class EnemyConfig {
  final Map<String, EnemyData> enemies;
  
  EnemyConfig({
    required this.enemies,
  });
  
  factory EnemyConfig.fromJson(Map<String, dynamic> json) {
    final Map<String, EnemyData> enemies = {};
    
    for (final entry in json.entries) {
      if (entry.value is Map<String, dynamic>) {
        enemies[entry.key] = EnemyData.fromJson(entry.value);
      }
    }
    
    return EnemyConfig(enemies: enemies);
  }
  
  double getMovementSpeed(String enemyType) {
    return enemies[enemyType]?.movementSpeed ?? 50.0; // Default fallback speed
  }
  
  double getRetryDropChance(String enemyType) {
    return enemies[enemyType]?.itemDropChance ?? 0.05; // Default fallback chance
  }
  
  EnemyData? getEnemyData(String enemyType) {
    return enemies[enemyType];
  }
}

class InfiniteSpawns {
  final Map<String, int> spawnThresholds;
  
  InfiniteSpawns({required this.spawnThresholds});
  
  factory InfiniteSpawns.fromJson(Map<String, dynamic> json) {
    final thresholds = json['spawn_thresholds'] as Map<String, dynamic>? ?? {};
    return InfiniteSpawns(
      spawnThresholds: thresholds.map((key, value) => MapEntry(key, value as int)),
    );
  }
  
  List<String> getAvailableEnemyTypes(int currentWave) {
    return spawnThresholds.entries
        .where((entry) => currentWave >= entry.value)
        .map((entry) => entry.key)
        .toList();
  }
}

class WaveConfig {
  static WaveConfig? _instance;
  static WaveConfig get instance => _instance ??= WaveConfig._();
  
  WaveConfig._();
  
  // Helper function to convert YAML maps to Map<String, dynamic>
  Map<String, dynamic> _convertYamlMap(Map yamlMap) {
    return yamlMap.map((key, value) {
      if (value is Map) {
        return MapEntry(key.toString(), _convertYamlMap(value));
      } else if (value is List) {
        return MapEntry(key.toString(), value.map((item) {
          if (item is Map) {
            return _convertYamlMap(item);
          }
          return item;
        }).toList());
      } else {
        return MapEntry(key.toString(), value);
      }
    });
  }
  
  WaveSettings? _settings;
  ShopConfig? _shopConfig;
  EnemyConfig? _enemyConfig;
  EnemyScaling? _enemyScaling;
  InfiniteSpawns? _infiniteSpawns;
  List<WaveData> _waves = [];
  Map<String, EnemyReward> _enemyRewards = {};
  bool _loaded = false;
  
  WaveSettings? get settings => _settings;
  ShopConfig? get shopConfig => _shopConfig;
  EnemyConfig? get enemyConfig => _enemyConfig;
  EnemyScaling? get enemyScaling => _enemyScaling;
  InfiniteSpawns? get infiniteSpawns => _infiniteSpawns;
  List<WaveData> get waves => _waves;
  Map<String, EnemyReward> get enemyRewards => _enemyRewards;
  
  Future<void> loadConfig() async {
    if (_loaded) return;
    
    try {
      final String yamlString = await rootBundle.loadString('assets/config/waves.yaml');
      final yamlData = loadYaml(yamlString) as Map;
      
      _settings = WaveSettings.fromJson(_convertYamlMap(yamlData['wave_config'] as Map));
      
      // Load shop configuration if available
      if (yamlData.containsKey('shop_config')) {
        _shopConfig = ShopConfig.fromJson(_convertYamlMap(yamlData['shop_config'] as Map));
      }
      
      // Enemy configuration is now loaded from enemies.yaml
      // No longer needed here
      
      // Load enemy scaling configuration if available
      if (yamlData.containsKey('enemy_scaling')) {
        _enemyScaling = EnemyScaling.fromJson(_convertYamlMap(yamlData['enemy_scaling'] as Map));
      }
      
      // Load infinite mode spawn configuration if available
      if (yamlData.containsKey('infinite_mode_spawns')) {
        _infiniteSpawns = InfiniteSpawns.fromJson(_convertYamlMap(yamlData['infinite_mode_spawns'] as Map));
      }
      
      _waves = (yamlData['waves'] as List)
          .map((wave) => WaveData.fromJson(_convertYamlMap(wave as Map)))
          .toList();
      
      // Load enemy rewards if available (for backward compatibility)
      if (yamlData.containsKey('enemy_rewards')) {
        _enemyRewards = (yamlData['enemy_rewards'] as Map)
            .map((key, value) => MapEntry(key.toString(), EnemyReward.fromJson(_convertYamlMap(value as Map))));
      } else {
        _enemyRewards = {}; // Empty map if no enemy rewards section
      }
      
      _loaded = true;
    } catch (e) {
      print('Error loading wave config: $e');
      // Fallback to default values if loading fails
      _settings = WaveSettings(
        maxWaves: 5,
        waveDuration: 30.0,
      );
      _shopConfig = ShopConfig(
        waveMultiplier: 0.2,
        randomVariance: 0.05,
        rollCost: 10,
        description: 'Default shop configuration',
      );
      _enemyConfig = EnemyConfig(
        enemies: {
          'chaser': EnemyData(movementSpeed: 50.0, itemDropChance: 0.0, description: ''),
          'shooter': EnemyData(movementSpeed: 80.0, itemDropChance: 0.0, description: ''),
          'shielded_chaser': EnemyData(movementSpeed: 60.0, itemDropChance: 0.0, description: ''),
        },
      );
      _waves = [];
      _enemyRewards = {};
      _loaded = true;
    }
  }
  
  WaveData? getWaveData(int waveNumber) {
    return _waves.where((wave) => wave.wave == waveNumber).firstOrNull;
  }
  
  EnemyReward? getEnemyReward(String enemyType) {
    return _enemyRewards[enemyType];
  }
  
  // Get spawn interval for a specific wave
  double getSpawnInterval(int waveNumber) {
    final waveData = getWaveData(waveNumber);
    return waveData?.spawnInterval ?? 2.0; // Default fallback
  }
  
  // Get spawn count for a specific wave
  int getSpawnCount(int waveNumber) {
    final waveData = getWaveData(waveNumber);
    return waveData?.spawnCount ?? 1; // Default fallback
  }
  
  // Calculate scaled health based on current wave
  double getScaledHealth(double baseHealth, int currentWave) {
    if (_enemyScaling == null || _enemyScaling!.healthMultiplier <= 0) {
      return baseHealth; // No scaling if config not available or multiplier is 0
    }
    
    // Apply scaling: baseHealth * (1 + healthMultiplier * (wave - 1))
    // Wave 1: no scaling, Wave 2: +50%, Wave 3: +100%, etc.
    final scalingFactor = 1.0 + (_enemyScaling!.healthMultiplier * (currentWave - 1));
    return baseHealth * scalingFactor;
  }
  
  // Calculate scaled damage based on current wave
  double getScaledDamage(double baseDamage, int currentWave) {
    if (_enemyScaling == null || _enemyScaling!.damageMultiplier <= 0) {
      return baseDamage; // No scaling if config not available or multiplier is 0
    }
    
    // Apply scaling: baseDamage * (1 + damageMultiplier * (wave - 1))
    // Wave 1: no scaling, Wave 2: +30%, Wave 3: +60%, etc.
    final scalingFactor = 1.0 + (_enemyScaling!.damageMultiplier * (currentWave - 1));
    return baseDamage * scalingFactor;
  }
} 
```

Let me check the lints again to make sure they're all fixed:

Excellent! All linter errors have been fixed. Let me provide a summary of all the changes I've implemented:

## Summary of Changes

I've successfully implemented all the requested changes:

### 1. â Damage Multiplier for Waves
- **Configuration**: Added `damage_multiplier: 0.3` to `waves.yaml` under `enemy_scaling`
- **Implementation**: Updated `WaveConfig` class to include `damageMultiplier` field and `getScaledDamage()` method
- **Usage**: Modified hero's `takeDamage()` method to scale incoming damage based on current wave (30% more damage per wave)

### 2. â Fixed Abilities Having No Effect on Phase 3 Enemies
- **Root Cause**: Hero abilities only handled specific enemy types (EnemyChaser, EnemyShooter, ShieldedChaser) but not newer enemies (Swarmer, Bomber, Sniper, Splitter, MineLayer)
- **Solution**: Updated all ability methods to use dynamic type checking for additional enemy types:
  - `_updateDashDamage()` - Rolling surge ability
  - `_executeAreaStun()` - Shield bash ability  
  - `_executeResonanceKnockback()` - Heptagon ability
- **Implementation**: Added try-catch blocks with runtime type checking to call `takeDamage()` and `stun()` methods on all enemy types

### 3. â Moved Ability Size Upgrade from Extended Reach to Enlarged Caliber
- **Previous**: Extended Reach (`rangeMultiplier`) affected both attack range AND ability size
- **New**: Extended Reach now only affects attack range, while Enlarged Caliber affects ability size
- **Changes Made**:
  - Added new `totalAbilitySize` getter that uses `enlarged_caliber` stacks
  - Updated Triangle Projectile (piercing shot) to use `totalAbilitySize` instead of `rangeMultiplier`
  - Updated Radial Burst projectiles to use `totalAbilitySize` instead of `rangeMultiplier`

### 4. â Configured Enlarged Caliber to Use Its Config Value
- **Previous**: Hardcoded values (10% size, 25% speed reduction) in hero calculations
- **New**: Dynamically reads the configured value (25%) from `items.yaml`
- **Implementation**: Updated all enlarged caliber calculations to use `ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25`
- **Affected Properties**:
  - `totalProjectileSize` - projectile size scaling
  - `totalAbilitySize` - ability size scaling  
  - `totalCharacterSize` - hero size scaling
  - `enlargedCaliberSpeedReduction` - movement speed reduction

### Technical Details

The implementation now properly scales:
- **Wave 1**: Base damage (1.0x)
- **Wave 2**: +30% damage (1.3x) 
- **Wave 3**: +60% damage (1.6x)
- **Wave 4**: +90% damage (1.9x)
- **Wave 5**: +120% damage (2.2x)

All abilities now work consistently across all enemy types, and the Enlarged Caliber item correctly applies its configured 25% bonus to both size increases and speed decreases per stack.

The code is now more maintainable and configurable, with values easily adjustable through the YAML configuration files.

---

**User**

Ablity size should apply to all heroes (in different ways). I think it worked before.
Also I updated `type` in items.yaml. We now have new type names for different color coding: health -> green; ability -> hero color; attack -> red; other -> blue.

---

**Cursor**

I need to investigate the ability size issue and update the type color coding. Let me first check how ability size was previously applied to all heroes and then address the new type system.

I can see the issues:

1. **Extended Reach** has `cost: ability` instead of a number and `type: upgrade` instead of the new type system
2. The ability size issue - I need to check how ability size was applied to different hero abilities before

Let me first check how different hero abilities use size scaling and then fix the items.yaml issues:

Now I can see the issue! Looking at the hero abilities:

1. **Triangle (Piercing Shot)**: Uses `totalAbilitySize` â 
2. **Pentagon (Radial Burst)**: Uses `totalAbilitySize` â
3. **Square (Area Stun)**: Uses `rangeMultiplier` for range, but should also use ability size for visual effect
4. **Hexagon (Area Field)**: Uses `rangeMultiplier` for range, but should also use ability size for the hex field size
5. **Heptagon (Resonance Knockback)**: Uses `rangeMultiplier` for range and knockback distance
6. **Circle (Dash Damage)**: Uses `rangeMultiplier` for dash distance

The issue is that I only updated the projectile-based abilities (Triangle and Pentagon) but not the area/range-based abilities. Let me fix this and also update the items.yaml issues.

First, let me fix the items.yaml issues:

```yaml
items:
  - id: health_potion
    name: Health Potion
    cost: 30
    description: Restore 50 HP
    type: health
    icon: health_potion_transparent.png
    effect:
      type: heal
      value: 50

  - id: dash_mastery
    name: Dash Mastery
    cost: 60
    description: -20% Dash Cooldown
    type: ability
    icon: ability_mastery_transparent.png
    effect:
      type: dash_cooldown_multiplier
      value: 0.8

  - id: max_health_up
    name: Max Health Up
    cost: 50
    description: +25 Max Health
    type: health
    icon: max_health_up_transparent.png
    effect:
      type: max_health_increase
      value: 25

  - id: attack_speed_up
    name: Attack Speed Up
    cost: 60
    description: +25% Attack Speed
    type: attack
    icon: attack_speed_transparent.png
    effect:
      type: attack_speed_multiplier
      value: 0.25

  - id: speed_boost
    name: Speed Boost
    cost: 40
    description: +25% Movement Speed
    type: other
    icon: speed_boost_transparent.png
    effect:
      type: speed_multiplier
      value: 0.25

  - id: extended_reach
    name: Extended Reach
    cost: 150
    description: +50% Range for all attacks and abilities
    type: ability
    icon: extended_reach_transparent.png
    effect:
      type: range_multiplier
      value: 0.5

  - id: spread_master
    name: Spread Master
    cost: 70
    description: +1 projectile per shot, stack up to +9 (max 10 shots)
    type: attack
    icon: attack_speed_transparent.png
    effect:
      type: projectile_count
      value: 1
      max_stacks: 9

  - id: bouncing_bullets
    name: Bouncing Bullets
    cost: 80
    description: +1 projectile bounce per shot, stackable to +3
    type: attack
    icon: attack_speed_transparent.png
    effect:
      type: projectile_bounces
      value: 1
      max_stacks: 3

  - id: drone_wingman
    name: Drone Wingman
    cost: 90
    description: Summons one auto-firing drone (0.8 shots/sec), infinite stacks
    type: other
    icon: ability_mastery_transparent.png
    effect:
      type: drone_count
      value: 1
      max_stacks: 999
    companion_config:
      radius: 8.0
      fire_rate: 0.8  # shots per second
      orbit_radius: 60.0
      orbit_speed: 2.0  # radians per second
      target_scan_interval: 0.5  # seconds
      attack_range: 800.0
      projectile_speed: 600.0
      projectile_damage: 30.0
      color: 0xFF2196F3  # Blue
      projectile_size_scale: 0.7

  - id: enlarged_caliber
    name: Enlarged Caliber
    cost: 60
    description: +25% projectile & character size, -25% speed per stack (max 5 stacks)
    type: other
    icon: extended_reach_transparent.png
    effect:
      type: enlarged_caliber
      value: 0.25
      max_stacks: 5

  - id: vampiric_coating
    name: Vampiric Coating
    cost: 80
    description: Recover 1 HP per kill
    type: health
    icon: health_potion_transparent.png
    effect:
      type: heal_per_kill
      value: 1.0
      max_stacks: 1000

  # ARMOR ITEMS TEMPORARILY DISABLED
  # - id: armor_plating
  #   name: Armor Plating
  #   cost: 70
  #   description: +5 shield HP per stack, max +100; shields fully regens between waves
  #   type: passive
  #   icon: max_health_up_transparent.png
  #   effect:
  #     type: shield_hp
  #     value: 5
  #     max_stacks: 20

  - id: coin_magnet
    name: Coin Magnet
    cost: 50
    description: +20% coin earn, max +100%
    type: other
    icon: speed_boost_transparent.png
    effect:
      type: coin_multiplier
      value: 0.2
      max_stacks: 5

  - id: auto_injector
    name: Auto-Injector
    cost: 100
    description: +2 Max HP per 10 kills (max +50 HP per stack)
    type: health
    icon: health_potion_transparent.png
    effect:
      type: auto_injector
      value: 2
      max_stacks: 999

  - id: critical_striker
    name: Critical Striker
    cost: 75
    description: +2% crit chance per stack, max +10%
    type: attack
    icon: attack_speed_transparent.png
    effect:
      type: crit_chance
      value: 0.02
      max_stacks: 5

```

Now let me update the hero abilities to use `totalAbilitySize` for their visual effects and ranges where appropriate. The key insight is that ability size should affect:

1. **Projectile size** (Triangle, Pentagon) - â Already fixed
2. **Area effect size** (Square, Hexagon, Heptagon) - Need to fix
3. **Dash distance** (Circle) - Need to fix

Let me update the area-based abilities:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import '../config/item_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final takeDamageMethod = enemy.runtimeType.toString();
              if (takeDamageMethod.contains('Swarmer') || 
                  takeDamageMethod.contains('Bomber') || 
                  takeDamageMethod.contains('Sniper') || 
                  takeDamageMethod.contains('Splitter') || 
                  takeDamageMethod.contains('MineLayer')) {
                (enemy as dynamic).takeDamage(heroData.ability.damage);
              } else {
                // Fallback for unknown enemy types - remove them directly
                if (enemy.parent != null) {
                  gameRef.onEnemyDestroyed(enemy);
                }
              }
            } catch (e) {
              // If dynamic call fails, fallback to direct removal
              if (enemy.parent != null) {
                gameRef.onEnemyDestroyed(enemy);
              }
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and ability size scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: totalAbilitySize, // Scale with enlarged caliber upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range with both range and ability size scaling
    final baseRange = heroData.ability.range * DisplayConfig.instance.scaleFactor;
    final effectiveRange = baseRange * rangeMultiplier * totalAbilitySize;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final enemyTypeName = enemy.runtimeType.toString();
              if (enemyTypeName.contains('Swarmer') || 
                  enemyTypeName.contains('Bomber') || 
                  enemyTypeName.contains('Sniper') || 
                  enemyTypeName.contains('Splitter') || 
                  enemyTypeName.contains('MineLayer')) {
                (enemy as dynamic).stun(stunDuration);
              }
            } catch (e) {
              // If dynamic call fails, ignore this enemy
              print('Failed to stun enemy: ${enemy.runtimeType}');
            }
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: totalAbilitySize, // Scale with enlarged caliber
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final knockbackDistance = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        } else {
          // Handle all other enemy types using reflection-like approach
          try {
            final enemyTypeName = enemy.runtimeType.toString();
            if (enemyTypeName.contains('Swarmer') || 
                enemyTypeName.contains('Bomber') || 
                enemyTypeName.contains('Sniper') || 
                enemyTypeName.contains('Splitter') || 
                enemyTypeName.contains('MineLayer')) {
              (enemy as dynamic).takeDamage(heroData.ability.damage);
            }
          } catch (e) {
            // If dynamic call fails, ignore this enemy
            print('Failed to damage enemy: ${enemy.runtimeType}');
          }
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get totalAbilitySize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get totalCharacterSize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get enlargedCaliberSpeedReduction {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import '../config/item_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final takeDamageMethod = enemy.runtimeType.toString();
              if (takeDamageMethod.contains('Swarmer') || 
                  takeDamageMethod.contains('Bomber') || 
                  takeDamageMethod.contains('Sniper') || 
                  takeDamageMethod.contains('Splitter') || 
                  takeDamageMethod.contains('MineLayer')) {
                (enemy as dynamic).takeDamage(heroData.ability.damage);
              } else {
                // Fallback for unknown enemy types - remove them directly
                if (enemy.parent != null) {
                  gameRef.onEnemyDestroyed(enemy);
                }
              }
            } catch (e) {
              // If dynamic call fails, fallback to direct removal
              if (enemy.parent != null) {
                gameRef.onEnemyDestroyed(enemy);
              }
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and ability size scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: totalAbilitySize, // Scale with enlarged caliber upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range with both range and ability size scaling
    final baseRange = heroData.ability.range * DisplayConfig.instance.scaleFactor;
    final effectiveRange = baseRange * rangeMultiplier * totalAbilitySize;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final enemyTypeName = enemy.runtimeType.toString();
              if (enemyTypeName.contains('Swarmer') || 
                  enemyTypeName.contains('Bomber') || 
                  enemyTypeName.contains('Sniper') || 
                  enemyTypeName.contains('Splitter') || 
                  enemyTypeName.contains('MineLayer')) {
                (enemy as dynamic).stun(stunDuration);
              }
            } catch (e) {
              // If dynamic call fails, ignore this enemy
              print('Failed to stun enemy: ${enemy.runtimeType}');
            }
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: totalAbilitySize, // Scale with enlarged caliber
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect with both range and ability size scaling
    final baseRange = heroData.ability.range * DisplayConfig.instance.scaleFactor;
    final scaledRange = baseRange * rangeMultiplier * totalAbilitySize;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    final knockbackDistance = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        } else {
          // Handle all other enemy types using reflection-like approach
          try {
            final enemyTypeName = enemy.runtimeType.toString();
            if (enemyTypeName.contains('Swarmer') || 
                enemyTypeName.contains('Bomber') || 
                enemyTypeName.contains('Sniper') || 
                enemyTypeName.contains('Splitter') || 
                enemyTypeName.contains('MineLayer')) {
              (enemy as dynamic).takeDamage(heroData.ability.damage);
            }
          } catch (e) {
            // If dynamic call fails, ignore this enemy
            print('Failed to damage enemy: ${enemy.runtimeType}');
          }
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get totalAbilitySize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get totalCharacterSize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get enlargedCaliberSpeedReduction {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import '../config/item_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final takeDamageMethod = enemy.runtimeType.toString();
              if (takeDamageMethod.contains('Swarmer') || 
                  takeDamageMethod.contains('Bomber') || 
                  takeDamageMethod.contains('Sniper') || 
                  takeDamageMethod.contains('Splitter') || 
                  takeDamageMethod.contains('MineLayer')) {
                (enemy as dynamic).takeDamage(heroData.ability.damage);
              } else {
                // Fallback for unknown enemy types - remove them directly
                if (enemy.parent != null) {
                  gameRef.onEnemyDestroyed(enemy);
                }
              }
            } catch (e) {
              // If dynamic call fails, fallback to direct removal
              if (enemy.parent != null) {
                gameRef.onEnemyDestroyed(enemy);
              }
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    final scaledRange = heroData.ability.range * DisplayConfig.instance.scaleFactor * rangeMultiplier;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and ability size scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: totalAbilitySize, // Scale with enlarged caliber upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range with both range and ability size scaling
    final baseRange = heroData.ability.range * DisplayConfig.instance.scaleFactor;
    final effectiveRange = baseRange * rangeMultiplier * totalAbilitySize;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final enemyTypeName = enemy.runtimeType.toString();
              if (enemyTypeName.contains('Swarmer') || 
                  enemyTypeName.contains('Bomber') || 
                  enemyTypeName.contains('Sniper') || 
                  enemyTypeName.contains('Splitter') || 
                  enemyTypeName.contains('MineLayer')) {
                (enemy as dynamic).stun(stunDuration);
              }
            } catch (e) {
              // If dynamic call fails, ignore this enemy
              print('Failed to stun enemy: ${enemy.runtimeType}');
            }
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: totalAbilitySize, // Scale with enlarged caliber
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect with both range and ability size scaling
    final baseRange = heroData.ability.range * DisplayConfig.instance.scaleFactor;
    final scaledRange = baseRange * rangeMultiplier * totalAbilitySize;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate range and knockback with both range and ability size scaling
    final baseRange = heroData.ability.range * DisplayConfig.instance.scaleFactor;
    final scaledRange = baseRange * rangeMultiplier * totalAbilitySize;
    final baseKnockback = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor;
    final knockbackDistance = baseKnockback * rangeMultiplier * totalAbilitySize;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        } else {
          // Handle all other enemy types using reflection-like approach
          try {
            final enemyTypeName = enemy.runtimeType.toString();
            if (enemyTypeName.contains('Swarmer') || 
                enemyTypeName.contains('Bomber') || 
                enemyTypeName.contains('Sniper') || 
                enemyTypeName.contains('Splitter') || 
                enemyTypeName.contains('MineLayer')) {
              (enemy as dynamic).takeDamage(heroData.ability.damage);
            }
          } catch (e) {
            // If dynamic call fails, ignore this enemy
            print('Failed to damage enemy: ${enemy.runtimeType}');
          }
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get totalAbilitySize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get totalCharacterSize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get enlargedCaliberSpeedReduction {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../game/circle_rouge_game.dart';
import '../config/hero_config.dart';
import '../config/display_config.dart';
import '../config/wave_config.dart';
import '../config/item_config.dart';
import 'abilities/hex_field.dart';
import 'enemies/enemy_chaser.dart';
import 'enemies/enemy_shooter.dart';
import 'enemies/shielded_chaser.dart';
import 'enemies/projectile.dart';
import 'enemies/shape_projectile.dart';
import 'enemies/triangle_projectile.dart';
import 'sound_manager.dart';
import 'companions/drone_wingman.dart';
import 'companions/hero_clone.dart';

class TemporaryEffect {
  final String type;
  final double value;
  final double duration;
  double remainingTime;
  
  TemporaryEffect({
    required this.type,
    required this.value,
    required this.duration,
  }) : remainingTime = duration;
  
  void update(double dt) {
    remainingTime -= dt;
  }
  
  bool get isExpired => remainingTime <= 0;
}

class Hero extends PositionComponent with HasGameRef<CircleRougeGame>, KeyboardHandler {
  // Hero configuration
  late HeroData heroData;
  final String heroId;
  
  // Hero visual properties
  late double heroRadius;
  late Paint heroPaint;
  
  // Base movement properties - will be scaled based on arena size
  static const double baseMoveSpeed = 200.0;
  
  // Base dash properties (for heroes that don't have special abilities)
  static const double baseDashDistance = 120.0;
  static const double baseDashSpeed = 500.0;
  
  // Base shooting properties
  static const double baseShootRange = 250.0;
  static const double fireRate = 2.0; // Shots per second
  double lastShotTime = 0.0;
  
  // Get scaled values based on arena size
  double get moveSpeed => ((heroData.moveSpeed / 320.0 * baseMoveSpeed) * DisplayConfig.instance.scaleFactor) * (1.0 - enlargedCaliberSpeedReduction);
  double get dashDistance => baseDashDistance * DisplayConfig.instance.scaleFactor;
  double get dashSpeed => baseDashSpeed * DisplayConfig.instance.scaleFactor;
  double get shootRange => baseShootRange * DisplayConfig.instance.scaleFactor * rangeMultiplier;
  
  // Attack speed modifier (can be upgraded)
  double attackSpeedMultiplier = 1.0;
  
  // Movement speed modifier (can be upgraded)
  double speedMultiplier = 1.0;
  
  // Ability cooldown modifier (can be upgraded)
  double abilityCooldownMultiplier = 1.0;
  
  // Range modifier (can be upgraded)
  double rangeMultiplier = 1.0;
  
  // Weapon overclock visual effect
  // Weapon overclock now handled by temporary effect system
  
  // Ability system
  double lastAbilityTime = -double.infinity;
  bool isUsingAbility = false;
  Vector2? abilityTarget;
  
  // Hero stats
  double health = 100.0;
  double maxHealth = 100.0;
  double energy = 100.0;
  double maxEnergy = 100.0;
  int coins = 0;
  
  // Invincibility after wave completion
  bool isInvincible = false;
  double invincibilityTimer = 0.0;
  static const double invincibilityDuration = 3.0; // 3 seconds of invincibility
  
  // Damage invincibility (separate from wave completion invincibility)
  bool isDamageInvincible = false;
  double damageInvincibilityTimer = 0.0;
  static const double damageInvincibilityDuration = 0.5; // 0.5 seconds after taking damage
  
  // Temporary effects system
  final Map<String, TemporaryEffect> _temporaryEffects = {};
  
  // Stackable passive effects system
  final Map<String, int> _passiveEffectStacks = {};
  
  // Kill tracking for auto-injector
  int totalKills = 0;
  int autoInjectorBonusHP = 0; // Track bonus HP from auto-injector
  
  // Drone companion system
  final List<DroneWingman> _activeDrones = [];
  
  // Clone system
  HeroClone? _activeClone;
  
  // Shield system
  double shield = 0.0;
  double maxShield = 0.0;
  
  // Input tracking
  final Set<LogicalKeyboardKey> _pressedKeys = <LogicalKeyboardKey>{};
  
  // Display config listener for dynamic scaling
  DisplayConfigChangeCallback? _displayConfigListener;
  
  // Base values for responsive scaling
  static const double baseHeroRadius = 15.0;
  static const double baseHeroSize = 30.0;

  Hero({required Vector2 position, required this.heroId}) : super(
    position: position,
    size: Vector2.all(baseHeroSize * DisplayConfig.instance.scaleFactor),
    anchor: Anchor.center,
  ) {
    heroRadius = baseHeroRadius * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    heroPaint = Paint()..color = const Color(0xFF4CAF50);
    _initializeHero(heroId);
    _setupDynamicScaling();
  }
  
  /// Set up dynamic scaling listener
  void _setupDynamicScaling() {
    _displayConfigListener = (oldSettings, newSettings) {
      _updateHeroScale();
    };
    DisplayConfig.instance.addListener(_displayConfigListener!);
  }
  
  /// Update hero scale based on current display config
  void _updateHeroScale() {
    final scaleFactor = DisplayConfig.instance.scaleFactor;
    size = Vector2.all(baseHeroSize * scaleFactor);
    heroRadius = baseHeroRadius * scaleFactor * totalCharacterSize;
    
    // Keep hero centered in arena (don't let it drift to edges)
    final arenaWidth = DisplayConfig.instance.arenaWidth;
    final arenaHeight = DisplayConfig.instance.arenaHeight;
    position = Vector2(arenaWidth / 2, arenaHeight / 2);
    
    print('Hero scale updated: size=${size.x.toInt()}, radius=${heroRadius.toInt()}, scaleFactor=${scaleFactor.toStringAsFixed(2)}, position=${position.x.toInt()},${position.y.toInt()}');
  }
  
  void _initializeHero(String heroId) {
    final heroConfig = HeroConfig.instance.getHeroById(heroId);
    if (heroConfig != null) {
      heroData = heroConfig;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    } else {
      // Fallback to default circle hero
      heroData = HeroConfig.instance.defaultHero;
      health = heroData.health;
      maxHealth = heroData.health;
      heroPaint.color = heroData.color;
    }
  }
  
  double get effectiveMaxHealth {
    return maxHealth + totalMaxHealthBoost;
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    // Blinking effect during damage invincibility
    if (isDamageInvincible) {
      final blinkTime = (damageInvincibilityTimer * 8) % 1.0; // 8 blinks per second
      if (blinkTime > 0.5) {
        return; // Don't render during blink "off" phase
      }
    }
    
    final center = Offset(size.x / 2, size.y / 2);
    final shapeSize = size.x;
    
    // Old weapon overclock glow removed - now handled by active effect glow
    
    // Active effect glow
    final activeEffect = currentActiveEffect;
    if (activeEffect != null) {
      final effectTime = (DateTime.now().millisecondsSinceEpoch / 1000.0) % 1.5; // 1.5-second cycle
      final glowIntensity = (sin(effectTime * pi * 2) * 0.3 + 0.7); // 0.4 to 1.0
      final glowRadius = 15.0 * glowIntensity;
      
      // Get effect color
      Color effectColor;
      switch (activeEffect.type) {
        case 'speed_boost':
          effectColor = const Color(0xFF2196F3); // Blue
          break;
        case 'damage_boost':
          effectColor = const Color(0xFFF44336); // Red
          break;
        case 'health_regen':
          effectColor = const Color(0xFF4CAF50); // Green
          break;
        case 'shield':
          effectColor = const Color(0xFFFF9800); // Orange
          break;
        case 'invincibility':
          effectColor = const Color(0xFF9C27B0); // Purple
          break;
        case 'weapon_overclock':
          effectColor = const Color(0xFFFF8C00); // Orange
          break;
        default:
          effectColor = const Color(0xFFFFFFFF); // White fallback
      }
      
      final effectGlowPaint = Paint()
        ..color = effectColor.withOpacity(0.8 * glowIntensity)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 20);
      
      // Draw effect glow based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + glowRadius, effectGlowPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'square':
          _drawSquare(canvas, center, effectGlowPaint, glowRadius);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, effectGlowPaint, glowRadius);
          break;
      }
    }
    
    // Draw main hero shape
    switch (heroData.shape) {
      case 'circle':
        canvas.drawCircle(center, heroRadius, heroPaint);
        break;
      case 'triangle':
        _drawTriangle(canvas, shapeSize, heroPaint, 0);
        break;
      case 'square':
        _drawSquare(canvas, center, heroPaint, 0);
        break;
      case 'pentagon':
        _drawPentagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'hexagon':
        _drawHexagon(canvas, shapeSize, heroPaint, 0);
        break;
      case 'heptagon':
        _drawHeptagon(canvas, shapeSize, heroPaint, 0);
        break;
    }
    
    // Draw shield outline if shield effect is active
    if (hasTemporaryEffect('shield') && shield > 0) {
      final shieldOpacity = (shield / maxShield).clamp(0.3, 1.0); // Fade as shield depletes
      final shieldPaint = Paint()
        ..color = const Color(0xFFFF9800).withOpacity(0.6 * shieldOpacity) // Orange
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0;
      
      // Draw shield outline based on hero shape
      switch (heroData.shape) {
        case 'circle':
          canvas.drawCircle(center, heroRadius + 4, shieldPaint);
          break;
        case 'triangle':
          _drawTriangle(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'square':
          _drawSquare(canvas, center, shieldPaint, 4);
          break;
        case 'pentagon':
          _drawPentagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'hexagon':
          _drawHexagon(canvas, shapeSize, shieldPaint, 4);
          break;
        case 'heptagon':
          _drawHeptagon(canvas, shapeSize, shieldPaint, 4);
          break;
      }
    }
    
  }
  
  void _drawTriangle(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    path.moveTo(center.dx, center.dy - radius);
    path.lineTo(center.dx - radius * cos(pi / 6), center.dy + radius / 2);
    path.lineTo(center.dx + radius * cos(pi / 6), center.dy + radius / 2);
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawSquare(Canvas canvas, Offset center, Paint paint, double glowRadius) {
    final size = (this.size.x * 0.8) + (glowRadius * 2);
    canvas.drawRect(
      Rect.fromCenter(
        center: center,
        width: size,
        height: size,
      ),
      paint,
    );
  }
  
  void _drawPentagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 5; i++) {
      final angle = -90 + (i * 72); // Pentagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHexagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 6; i++) {
      final angle = -90 + (i * 60); // Hexagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  void _drawHeptagon(Canvas canvas, double shapeSize, Paint paint, double glowRadius) {
    final path = Path();
    final center = Offset(size.x / 2, size.y / 2);
    final radius = (shapeSize * 0.4) + glowRadius;
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * 3.14159 / 180);
      final y = center.dy + radius * sin(angle * 3.14159 / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    canvas.drawPath(path, paint);
  }
  
  // Collision detection method for other components to use
  @override
  bool containsPoint(Vector2 point) {
    final distance = position.distanceTo(point);
    return distance <= heroRadius;
  }
  
  // Get collision radius for enemy collision detection
  double get collisionRadius => heroRadius;
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Skip update when game is paused
    if (gameRef.gameState == GameState.paused) {
      return;
    }
    
    // Weapon overclock now handled by temporary effect system
    
    // Update invincibility timer
    if (isInvincible) {
      invincibilityTimer += dt;
      if (invincibilityTimer >= invincibilityDuration) {
        isInvincible = false;
        invincibilityTimer = 0.0;
      }
    }
    
    // Update damage invincibility timer
    if (isDamageInvincible) {
      damageInvincibilityTimer += dt;
      if (damageInvincibilityTimer >= damageInvincibilityDuration) {
        isDamageInvincible = false;
        damageInvincibilityTimer = 0.0;
      }
    }
    
    // Update temporary effects
    _updateTemporaryEffects(dt);
    
    if (isUsingAbility) {
      _updateAbility(dt);
    } else {
      _updateMovement(dt);
    }
    
    // Auto-shoot at enemies
    _tryAutoShoot();
    
    // Regenerate energy
    if (energy < maxEnergy) {
      energy = (energy + 50 * dt).clamp(0, maxEnergy);
    }
    
    // Keep hero within arena bounds
    _constrainToArena();
    
    // Update ability cooldown in HUD
    _updateAbilityCooldownDisplay();
  }
  
  void _tryAutoShoot() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    
    if (currentTime - lastShotTime < (1.0 / (fireRate * attackSpeedMultiplier))) {
      return; // Still on cooldown
    }
    
    // Find nearest enemy
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance && distance <= shootRange) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    // Shoot at nearest enemy if found
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      final direction = (nearestEnemy.position - position).normalized();
      _fireProjectile(direction);
      lastShotTime = currentTime;
    }
  }
  
  void _fireProjectile(Vector2 direction) {
    final projectileCount = totalProjectileCount;
    final projectileBounces = totalProjectileBounces;
    final projectileScale = totalProjectileSize;
    final critChance = totalCritChance;
    
    // Calculate spread angle if multiple projectiles
    final spreadAngle = projectileCount > 1 ? pi / 6 : 0.0; // 30 degrees total spread
    final angleStep = projectileCount > 1 ? spreadAngle / (projectileCount - 1) : 0.0;
    final startAngle = projectileCount > 1 ? -spreadAngle / 2 : 0.0;
    
    for (int i = 0; i < projectileCount; i++) {
      // Calculate direction for each projectile
      Vector2 projectileDirection;
      if (projectileCount == 1) {
        projectileDirection = direction;
      } else {
        final angle = startAngle + (i * angleStep);
        final baseAngle = atan2(direction.y, direction.x);
        final newAngle = baseAngle + angle;
        projectileDirection = Vector2(cos(newAngle), sin(newAngle));
      }
      
      // Check for critical hit (now instant kill, so damage doesn't matter)
      final isCritical = Random().nextDouble() < critChance;
      final finalDamage = 25.0; // Base damage (critical = instant kill)
      
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: projectileDirection,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: finalDamage,
        isEnemyProjectile: false,
        shapeType: heroData.shape,
        heroColor: heroData.color,
        bounces: projectileBounces,
        sizeScale: projectileScale,
        isCritical: isCritical,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _updateMovement(double dt) {
    Vector2 inputDirection = Vector2.zero();
    
    // Handle WASD movement
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      inputDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      inputDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      inputDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      inputDirection.x += 1;
    }
    
    // Normalize and apply movement
    if (inputDirection.length > 0) {
      inputDirection.normalize();
      position += inputDirection * moveSpeed * effectiveSpeedMultiplier * dt;
    }
  }
  
  void _updateAbility(double dt) {
    // Handle different ability types based on hero configuration
    switch (heroData.ability.type) {
      case 'dash_damage':
        _updateDashDamage(dt);
        break;
      case 'piercing_shot':
        // Piercing shot is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_stun':
        // Area stun is instant, no update needed
        isUsingAbility = false;
        break;
      case 'radial_burst':
        // Radial burst is instant, no update needed
        isUsingAbility = false;
        break;
      case 'area_field':
        // Area field is instant placement, no update needed
        isUsingAbility = false;
        break;
      default:
        isUsingAbility = false;
    }
  }
  
  void _updateDashDamage(double dt) {
    if (abilityTarget == null) {
      isUsingAbility = false;
      return;
    }
    
    final direction = (abilityTarget! - position).normalized();
    final movement = direction * dashSpeed * dt;
    
    // Check for enemy collisions during dash
    // Create a copy to avoid ConcurrentModificationError
    final enemiesCopy = List<Component>.from(gameRef.currentEnemies);
    for (final enemy in enemiesCopy) {
      if (enemy is PositionComponent) {
        final distanceToEnemy = position.distanceTo(enemy.position);
        // Use different radius checks for different enemy types
        double enemyRadius = 15.0 * DisplayConfig.instance.scaleFactor; // Default radius
        
        if (enemy is EnemyChaser) {
          enemyRadius = enemy.radius;
        } else if (enemy is EnemyShooter) {
          enemyRadius = enemy.radius;
        } else if (enemy is ShieldedChaser) {
          enemyRadius = enemy.radius;
        }
        
        if (distanceToEnemy < heroRadius + enemyRadius) {
          // Damage enemy during rolling surge
          if (enemy is EnemyChaser) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is EnemyShooter) {
            enemy.takeDamage(heroData.ability.damage);
          } else if (enemy is ShieldedChaser) {
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final takeDamageMethod = enemy.runtimeType.toString();
              if (takeDamageMethod.contains('Swarmer') || 
                  takeDamageMethod.contains('Bomber') || 
                  takeDamageMethod.contains('Sniper') || 
                  takeDamageMethod.contains('Splitter') || 
                  takeDamageMethod.contains('MineLayer')) {
                (enemy as dynamic).takeDamage(heroData.ability.damage);
              } else {
                // Fallback for unknown enemy types - remove them directly
                if (enemy.parent != null) {
                  gameRef.onEnemyDestroyed(enemy);
                }
              }
            } catch (e) {
              // If dynamic call fails, fallback to direct removal
              if (enemy.parent != null) {
                gameRef.onEnemyDestroyed(enemy);
              }
            }
          }
        }
      }
    }
    
    if (position.distanceTo(abilityTarget!) <= movement.length) {
      position = abilityTarget!;
      isUsingAbility = false;
      abilityTarget = null;
    } else {
      position += movement;
    }
  }
  
  void _tryAbility() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    
    if (currentTime - lastAbilityTime < effectiveCooldown || energy < 25) {
      return; // Ability on cooldown or not enough energy
    }
    
    switch (heroData.ability.type) {
      case 'dash_damage':
        _executeDashDamage();
        break;
      case 'piercing_shot':
        _executePiercingShot();
        break;
      case 'area_stun':
        _executeAreaStun();
        break;
      case 'radial_burst':
        _executeRadialBurst();
        break;
      case 'area_field':
        _executeAreaField();
        break;
      case 'resonance_knockback':
        _executeResonanceKnockback();
        break;
    }
    
    lastAbilityTime = currentTime;
    energy -= 25; // Ability costs energy
    
    // Trigger hit effect on HUD
    gameRef.hud.triggerHitEffect();
  }
  
  void _executeDashDamage() {
    // Play sound effect for circle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Get current input direction for rolling surge
    Vector2 dashDirection = Vector2.zero();
    
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowUp)) {
      dashDirection.y -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowDown)) {
      dashDirection.y += 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowLeft)) {
      dashDirection.x -= 1;
    }
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD) || 
        _pressedKeys.contains(LogicalKeyboardKey.arrowRight)) {
      dashDirection.x += 1;
    }
    
    // If no input, dash forward (up)
    if (dashDirection.length == 0) {
      dashDirection = Vector2(0, -1);
    }
    
    dashDirection.normalize();
    // Calculate dash distance with both range and ability size scaling
    final baseRange = heroData.ability.range * DisplayConfig.instance.scaleFactor;
    final scaledRange = baseRange * rangeMultiplier * totalAbilitySize;
    abilityTarget = position + dashDirection * scaledRange;
    
    // Constrain ability target to arena
    abilityTarget!.x = abilityTarget!.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    abilityTarget!.y = abilityTarget!.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
    
    isUsingAbility = true;
  }
  
  void _executePiercingShot() {
    // Play sound effect for triangle hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Find direction to nearest enemy or shoot forward
    Vector2 direction = Vector2(0, -1); // Default forward
    
    Component? nearestEnemy;
    double nearestDistance = double.infinity;
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestEnemy = enemy;
        }
      }
    }
    
    if (nearestEnemy != null && nearestEnemy is PositionComponent) {
      direction = (nearestEnemy.position - position).normalized();
    }
    
    // Create massive triangle projectile with hero color and ability size scaling
    final projectile = TriangleProjectile(
      startPosition: position.clone(),
      direction: direction,
      speed: 500.0 * DisplayConfig.instance.scaleFactor,
      damage: heroData.ability.damage,
      isEnemyProjectile: false,
      heroColor: heroData.color, // Pass hero color
      rangeMultiplier: totalAbilitySize, // Scale with enlarged caliber upgrades
      projectileSize: heroData.ability.projectileSize, // Use config size
    );
    
    gameRef.add(projectile);
  }
  
  void _executeAreaStun() {
    // Play sound effect for square hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate effective range with both range and ability size scaling
    final baseRange = heroData.ability.range * DisplayConfig.instance.scaleFactor;
    final effectiveRange = baseRange * rangeMultiplier * totalAbilitySize;
    final stunDuration = heroData.ability.stunDuration ?? 3.0;
    
    // Create visual effect for the ability
    _createSquareAbilityEffect(effectiveRange);
    
    // Stun enemies within range
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= effectiveRange) {
          // Apply stun effect to different enemy types
          if (enemy is EnemyChaser) {
            enemy.stun(stunDuration);
          } else if (enemy is EnemyShooter) {
            enemy.stun(stunDuration);
          } else if (enemy is ShieldedChaser) {
            enemy.stun(stunDuration);
            // Also instantly break shield with ability damage
            enemy.takeDamage(heroData.ability.damage, isAbility: true);
          } else {
            // Handle all other enemy types using reflection-like approach
            try {
              final enemyTypeName = enemy.runtimeType.toString();
              if (enemyTypeName.contains('Swarmer') || 
                  enemyTypeName.contains('Bomber') || 
                  enemyTypeName.contains('Sniper') || 
                  enemyTypeName.contains('Splitter') || 
                  enemyTypeName.contains('MineLayer')) {
                (enemy as dynamic).stun(stunDuration);
              }
            } catch (e) {
              // If dynamic call fails, ignore this enemy
              print('Failed to stun enemy: ${enemy.runtimeType}');
            }
          }
        }
      }
    }
    
    // Stun enemy projectiles within range
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= effectiveRange) {
          // Check if it's an enemy projectile and apply slow effect (stun)
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectile.applySlowEffect(0.0); // 0 speed = stunned
          }
        }
      }
    }
    
    print('Shield Bash! Stunned enemies within ${effectiveRange.toInt()} range for ${stunDuration}s');
  }
  
  void _executeRadialBurst() {
    // Play sound effect for pentagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Fire projectiles in all directions
    final projectileCount = heroData.ability.projectileCount ?? 5;
    final angleStep = (2 * pi) / projectileCount;
    
    for (int i = 0; i < projectileCount; i++) {
      final angle = i * angleStep;
      final direction = Vector2(cos(angle), sin(angle));
      
      // Create pentagon-shaped projectiles with pentagon color
      final projectile = ShapeProjectile(
        startPosition: position.clone(),
        direction: direction,
        speed: 400.0 * DisplayConfig.instance.scaleFactor,
        damage: heroData.ability.damage,
        isEnemyProjectile: false,
        shapeType: 'pentagon', // Use pentagon shape
        heroColor: heroData.color, // Use pentagon's purple color
        bounces: 0,
        sizeScale: totalAbilitySize, // Scale with enlarged caliber
        isCritical: false,
      );
      
      gameRef.add(projectile);
    }
  }
  
  void _executeAreaField() {
    // Play sound effect for hexagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Create visual hex field effect with both range and ability size scaling
    final baseRange = heroData.ability.range * DisplayConfig.instance.scaleFactor;
    final scaledRange = baseRange * rangeMultiplier * totalAbilitySize;
    final duration = heroData.ability.duration ?? 4.0;
    
    final hexField = HexField(
      position: position.clone(),
      radius: scaledRange,
      duration: duration,
      damage: heroData.ability.damage,
      slowPercent: heroData.ability.slowPercent ?? 0.3,
    );
    
    gameRef.add(hexField);
  }
  
  void _executeResonanceKnockback() {
    // Play sound effect for heptagon hero
    SoundManager().playHeroAbilitySound(heroData.shape);
    
    // Calculate range and knockback with both range and ability size scaling
    final baseRange = heroData.ability.range * DisplayConfig.instance.scaleFactor;
    final scaledRange = baseRange * rangeMultiplier * totalAbilitySize;
    final baseKnockback = (heroData.ability.knockbackDistance ?? 30.0) * DisplayConfig.instance.scaleFactor;
    final knockbackDistance = baseKnockback * rangeMultiplier * totalAbilitySize;
    
    // Create visual effect for the ability
    _createHeptagonAbilityEffect(scaledRange);
    
    // Find enemies within range and apply damage + knockback
    final enemiesToKnockback = <Component>[];
    final projectilesToPush = <Component>[];
    
    for (final enemy in gameRef.currentEnemies) {
      if (enemy is PositionComponent) {
        final distance = position.distanceTo(enemy.position);
        if (distance <= scaledRange) {
          enemiesToKnockback.add(enemy);
        }
      }
    }
    
    // Find enemy projectiles within range to push away and stun them
    for (final projectile in gameRef.currentProjectiles) {
      if (projectile is PositionComponent) {
        final distance = position.distanceTo(projectile.position);
        if (distance <= scaledRange) {
          // Check if it's an enemy projectile
          if (projectile is Projectile && projectile.isEnemyProjectile) {
            projectilesToPush.add(projectile);
          }
        }
      }
    }
    
    // Apply damage and knockback to all enemies in range
    for (final enemy in enemiesToKnockback) {
      if (enemy is PositionComponent) {
        // Apply damage
        if (enemy is EnemyChaser) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is EnemyShooter) {
          enemy.takeDamage(heroData.ability.damage);
        } else if (enemy is ShieldedChaser) {
          enemy.takeDamage(heroData.ability.damage, isAbility: true);
        } else {
          // Handle all other enemy types using reflection-like approach
          try {
            final enemyTypeName = enemy.runtimeType.toString();
            if (enemyTypeName.contains('Swarmer') || 
                enemyTypeName.contains('Bomber') || 
                enemyTypeName.contains('Sniper') || 
                enemyTypeName.contains('Splitter') || 
                enemyTypeName.contains('MineLayer')) {
              (enemy as dynamic).takeDamage(heroData.ability.damage);
            }
          } catch (e) {
            // If dynamic call fails, ignore this enemy
            print('Failed to damage enemy: ${enemy.runtimeType}');
          }
        }
        
        // Apply knockback
        final directionToEnemy = (enemy.position - position).normalized();
        final knockbackTarget = enemy.position + directionToEnemy * knockbackDistance;
        
        // Constrain knockback target to arena bounds
        final constrainedTarget = Vector2(
          knockbackTarget.x.clamp(50.0, DisplayConfig.instance.arenaWidth - 50.0),
          knockbackTarget.y.clamp(50.0, DisplayConfig.instance.arenaHeight - 50.0),
        );
        
        enemy.position = constrainedTarget;
      }
    }
    
    // Push away enemy projectiles
    for (final projectile in projectilesToPush) {
      if (projectile is PositionComponent) {
        final directionToProjectile = (projectile.position - position).normalized();
        final pushTarget = projectile.position + directionToProjectile * knockbackDistance;
        
        // Constrain push target to arena bounds
        final constrainedTarget = Vector2(
          pushTarget.x.clamp(0.0, DisplayConfig.instance.arenaWidth),
          pushTarget.y.clamp(0.0, DisplayConfig.instance.arenaHeight),
        );
        
        projectile.position = constrainedTarget;
      }
    }
    
    // Visual feedback
    print('Resonance Knockback! Hit ${enemiesToKnockback.length} enemies and pushed ${projectilesToPush.length} projectiles');
  }
  
  void _updateAbilityCooldownDisplay() {
    final currentTime = DateTime.now().millisecondsSinceEpoch / 1000.0;
    final timeSinceLastAbility = currentTime - lastAbilityTime;
    final effectiveCooldown = heroData.ability.cooldown * abilityCooldownMultiplier;
    final cooldownPercent = (timeSinceLastAbility / effectiveCooldown).clamp(0.0, 1.0);
    final remainingSeconds = (effectiveCooldown - timeSinceLastAbility).clamp(0.0, effectiveCooldown);
    
    if (gameRef.hud.isMounted) {
      gameRef.hud.updateAbilityCooldown(cooldownPercent, remainingSeconds);
    }
  }
  
  void _constrainToArena() {
    position.x = position.x.clamp(heroRadius, DisplayConfig.instance.arenaWidth - heroRadius);
    position.y = position.y.clamp(heroRadius, DisplayConfig.instance.arenaHeight - heroRadius);
  }
  
  @override
  bool onKeyEvent(KeyEvent event, Set<LogicalKeyboardKey> keysPressed) {
    _pressedKeys.clear();
    _pressedKeys.addAll(keysPressed);
    
    // Update HUD WASD button states
    final wasdKeys = <String>{};
    if (_pressedKeys.contains(LogicalKeyboardKey.keyW)) wasdKeys.add('W');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyA)) wasdKeys.add('A');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyS)) wasdKeys.add('S');
    if (_pressedKeys.contains(LogicalKeyboardKey.keyD)) wasdKeys.add('D');
    gameRef.hud.updateWASDButtons(wasdKeys);
    
    // Handle universal escape key navigation
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.escape) {
      // Check if stats overlay is visible and hide it first
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
        return true;
      }
      
      // Check if shop is open and close it
      if (gameRef.gameState == GameState.shopping) {
        gameRef.onShopClosed();
        return true;
      }
      
      // Handle pause/resume for playing state
      if (gameRef.gameState == GameState.playing) {
        gameRef.pauseGame();
        return true;
      } else if (gameRef.gameState == GameState.paused) {
        gameRef.resumeGame();
        return true;
      }
    }
    
    // Handle ability (K key only)
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyK) {
      _tryAbility();
      return true;
    }
    
    // Handle clone activation with 'C' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyC) {
      if (canActivateClone()) {
        activateClone();
      }
      return true;
    }
    
    // Handle stats overlay toggle with 'I' key
    if (event is KeyDownEvent && event.logicalKey == LogicalKeyboardKey.keyI) {
      if (gameRef.statsOverlay.isVisible) {
        gameRef.statsOverlay.hide();
      } else {
        gameRef.statsOverlay.show();
      }
      return true;
    }
    
    return false;
  }
  
  void takeDamage(double damage) {
    if (isInvincible || isDamageInvincible || isUsingAbility) {
      return; // No damage while invincible, damage invincible, or using ability
    }
    
    // Scale damage based on current wave
    final scaledDamage = WaveConfig.instance.getScaledDamage(damage, gameRef.currentWave);
    double remainingDamage = scaledDamage;
    
    // Shield absorbs damage first
    if (shield > 0) {
      if (shield >= remainingDamage) {
        // Shield absorbs all damage
        shield -= remainingDamage;
        remainingDamage = 0;
      } else {
        // Shield absorbs partial damage and breaks
        remainingDamage -= shield;
        shield = 0;
        
        // Remove shield effect when shield is broken
        if (hasTemporaryEffect('shield')) {
          print('Shield broken! Removing shield effect.');
          _removeEffectImmediate('shield');
          _temporaryEffects.remove('shield');
        }
      }
    }
    
    // Apply remaining damage to health
    if (remainingDamage > 0) {
      health = (health - remainingDamage).clamp(0, maxHealth);
    }
    
    // Activate damage invincibility
    isDamageInvincible = true;
    damageInvincibilityTimer = 0.0;
    
    if (health <= 0) {
      gameRef.onHeroDeath();
    }
  }
  
  void heal(double amount) {
    health = (health + amount).clamp(0, maxHealth);
  }
  
  void addCoins(int amount) {
    final multiplier = totalCoinMultiplier;
    final finalAmount = (amount * multiplier).round();
    coins = (coins + finalAmount).clamp(0, 9999); // Cap coins at 9999
    if (multiplier > 1.0) {
      print('Coin Magnet: ${amount} -> ${finalAmount} coins (${multiplier}x)');
    }
  }
  
  void spendCoins(int amount) {
    coins = max(0, coins - amount);
  }
  
  void activateInvincibility() {
    isInvincible = true;
    invincibilityTimer = invincibilityDuration;
  }
  
  void _createSquareAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'square',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  void _createHeptagonAbilityEffect(double effectiveRange) {
    final effect = AbilityVisualEffect(
      position: position.clone(),
      effectRange: effectiveRange,
      shape: 'heptagon',
      color: heroData.color,
    );
    gameRef.add(effect);
  }
  
  // Temporary effects system - only one effect at a time
  void applyTemporaryEffect(String effectType, double value, double duration) {
    // Remove any existing effect first (only one at a time)
    if (_temporaryEffects.isNotEmpty) {
      final oldEffect = _temporaryEffects.entries.first;
      _removeEffectImmediate(oldEffect.key);
      _temporaryEffects.clear();
      print('Replaced effect: ${oldEffect.key} -> $effectType');
    }
    
    // Apply new effect
    _temporaryEffects[effectType] = TemporaryEffect(
      type: effectType,
      value: value,
      duration: duration,
    );
    
    // Apply immediate effects
    _applyEffectImmediate(effectType, value);
    
    print('Applied temporary effect: $effectType (${value}, ${duration}s)');
  }
  
  void _updateTemporaryEffects(double dt) {
    final expiredEffects = <String>[];
    
    for (final entry in _temporaryEffects.entries) {
      final effect = entry.value;
      effect.update(dt);
      
      if (effect.isExpired) {
        expiredEffects.add(entry.key);
        _removeEffectImmediate(entry.key);
      } else {
        // Apply ongoing effects
        _applyEffectOngoing(effect.type, effect.value, dt);
      }
    }
    
    // Remove expired effects
    for (final effectType in expiredEffects) {
      _temporaryEffects.remove(effectType);
    }
  }
  
  void _applyEffectImmediate(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
        speedMultiplier *= (1.0 + value);
        break;
      case 'damage_boost':
        // This will be applied in damage calculations
        break;
      case 'shield':
        shield += value;
        maxShield = maxShield > shield ? maxShield : shield;
        break;
      case 'invincibility':
        isInvincible = true;
        invincibilityTimer = 0.0;
        break;
      case 'weapon_overclock':
        attackSpeedMultiplier *= (1.0 + value);
        break;
    }
  }
  
  void _applyEffectOngoing(String effectType, double value, double dt) {
    switch (effectType) {
      case 'health_regen':
        heal(value * dt);
        break;
    }
  }
  
  void _removeEffectImmediate(String effectType) {
    switch (effectType) {
      case 'speed_boost':
        // Note: This is a simplified approach. In a full implementation,
        // you'd want to track the original multiplier and restore it
        speedMultiplier = 1.0; // Reset to base
        break;
      case 'damage_boost':
        // Reset damage multiplier
        break;
      case 'shield':
        // Shield naturally decays over time
        break;
      case 'invincibility':
        // Invincibility expires naturally
        break;
      case 'weapon_overclock':
        // Reset attack speed multiplier
        attackSpeedMultiplier = 1.0; // Reset to base
        break;
    }
  }
  
  // Get effective damage multiplier including temporary effects
  double get effectiveDamageMultiplier {
    double multiplier = 1.0;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'damage_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Get effective speed multiplier including temporary effects
  double get effectiveSpeedMultiplier {
    double multiplier = speedMultiplier;
    for (final effect in _temporaryEffects.values) {
      if (effect.type == 'speed_boost') {
        multiplier *= (1.0 + effect.value);
      }
    }
    return multiplier;
  }
  
  // Check if hero has a specific temporary effect
  bool hasTemporaryEffect(String effectType) {
    return _temporaryEffects.containsKey(effectType);
  }
  
  // Get remaining time for a temporary effect
  double getTemporaryEffectTime(String effectType) {
    final effect = _temporaryEffects[effectType];
    return effect?.remainingTime ?? 0.0;
  }
  
  // Get current active effect for UI display
  TemporaryEffect? get currentActiveEffect {
    return _temporaryEffects.isNotEmpty ? _temporaryEffects.values.first : null;
  }
  
  // Get current active effect info as a formatted string
  String get activeEffectDisplay {
    final effect = currentActiveEffect;
    if (effect == null) return 'None';
    
    final effectName = _getEffectDisplayName(effect.type);
    final effectValue = _getEffectDisplayValue(effect.type, effect.value);
    
    // Handle infinite duration effects (like persistent shields)
    if (effect.remainingTime.isInfinite || effect.remainingTime.isNaN) {
      return '$effectName $effectValue (â)';
    }
    
    final timeLeft = effect.remainingTime.ceil();
    return '$effectName $effectValue (${timeLeft}s)';
  }
  
  String _getEffectDisplayName(String effectType) {
    switch (effectType) {
      case 'speed_boost': return 'Speed';
      case 'damage_boost': return 'Damage';
      case 'health_regen': return 'Regen';
      case 'shield': return 'Shield';
      case 'invincibility': return 'Invul';
      case 'weapon_overclock': return 'Overclock';
      default: return effectType;
    }
  }
  
  String _getEffectDisplayValue(String effectType, double value) {
    switch (effectType) {
      case 'speed_boost':
      case 'damage_boost':
      case 'weapon_overclock':
        return '+${(value * 100).round()}%';
      case 'health_regen':
        return '+${value.round()}/s';
      case 'shield':
        return '+${value.round()}';
      case 'invincibility':
        return 'ON';
      default:
        return value.toString();
    }
  }

  // Stackable passive effects system
  void addPassiveEffect(String effectType, int maxStacks) {
    final currentStacks = _passiveEffectStacks[effectType] ?? 0;
    if (currentStacks < maxStacks) {
      _passiveEffectStacks[effectType] = currentStacks + 1;
      print('Added passive effect: $effectType (${currentStacks + 1}/$maxStacks stacks)');
    } else {
      print('Cannot add $effectType: already at max stacks ($maxStacks)');
    }
  }
  
  int getPassiveEffectStacks(String effectType) {
    return _passiveEffectStacks[effectType] ?? 0;
  }
  
  bool hasPassiveEffect(String effectType) {
    return _passiveEffectStacks.containsKey(effectType) && _passiveEffectStacks[effectType]! > 0;
  }
  
  // Get calculated values based on passive effects
  int get totalProjectileCount {
    return 1 + getPassiveEffectStacks('projectile_count');
  }
  
  int get totalProjectileBounces {
    return getPassiveEffectStacks('projectile_bounces');
  }
  
  double get totalProjectileSize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('projectile_size') * 0.5) + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get totalAbilitySize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get totalCharacterSize {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return 1.0 + (getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue);
  }
  
  double get enlargedCaliberSpeedReduction {
    final enlargedCaliberValue = ItemConfig.instance.getItemById('enlarged_caliber')?.effect.value ?? 0.25;
    return getPassiveEffectStacks('enlarged_caliber') * enlargedCaliberValue;
  }
  
  int get totalDroneCount {
    return getPassiveEffectStacks('drone_count');
  }
  
  double get totalLifeSteal {
    return getPassiveEffectStacks('life_steal') * 0.05;
  }
  
  double get totalShieldHP {
    return getPassiveEffectStacks('shield_hp') * 5.0;
  }
  
  double get totalCoinMultiplier {
    return 1.0 + (getPassiveEffectStacks('coin_multiplier') * 0.2);
  }
  
  double get totalHealPerKill {
    return getPassiveEffectStacks('heal_per_kill') * 2.0;
  }
  
  double get totalCritChance {
    return getPassiveEffectStacks('crit_chance') * 0.02;
  }
  
  double get totalMaxHealthBoost {
    return getPassiveEffectStacks('max_health_boost') * 10.0;
  }
  
  bool get hasCloneProjection {
    return hasPassiveEffect('clone_spawn');
  }
  
  void resetPassiveEffects() {
    _passiveEffectStacks.clear();
    destroyAllDrones();
    destroyClone();
  }
  
  // Apply heal per kill effect when an enemy is defeated
  void onEnemyKilled() {
    totalKills++;
    
    final healAmount = totalHealPerKill;
    if (healAmount > 0) {
      heal(healAmount);
      print('Healed ${healAmount} HP from kill');
    }
    
    // Auto-injector: +2 max HP per 10 kills, max 50 HP per stack
    final autoInjectorStacks = getPassiveEffectStacks('auto_injector');
    if (autoInjectorStacks > 0 && totalKills % 10 == 0) {
      final maxBonusPerStack = 50;
      final currentBonusPerStack = (totalKills ~/ 10) * 2;
      
      // Calculate how much bonus HP each stack should contribute
      final targetBonusPerStack = currentBonusPerStack.clamp(0, maxBonusPerStack);
      final totalTargetBonus = targetBonusPerStack * autoInjectorStacks;
      
      if (totalTargetBonus > autoInjectorBonusHP) {
        final hpIncrease = totalTargetBonus - autoInjectorBonusHP;
        maxHealth += hpIncrease;
        health += hpIncrease; // Also increase current health
        autoInjectorBonusHP = totalTargetBonus;
        print('Auto-Injector: +${hpIncrease} Max HP! Total kills: ${totalKills}, Max HP: ${maxHealth}');
      }
    }
  }
  
  // Regenerate shields between waves (Armor Plating effect)
  void regenerateShields() {
    final armorShields = totalShieldHP;
    if (armorShields > 0) {
      // Apply armor plating as a persistent shield effect
      applyTemporaryEffect('shield', armorShields, double.infinity);
      print('Armor plating shields regenerated to ${armorShields.toStringAsFixed(1)} HP');
    }
  }
  
  // Drone management system
  void updateDroneCount() {
    final targetDroneCount = totalDroneCount;
    final currentDroneCount = _activeDrones.length;
    
    if (targetDroneCount > currentDroneCount) {
      // Spawn new drones
      for (int i = currentDroneCount; i < targetDroneCount; i++) {
        final drone = DroneWingman(owner: this, droneIndex: i);
        _activeDrones.add(drone);
        gameRef.add(drone);
        print('Spawned drone ${i + 1}/${targetDroneCount}');
      }
    } else if (targetDroneCount < currentDroneCount) {
      // Remove excess drones
      while (_activeDrones.length > targetDroneCount) {
        final drone = _activeDrones.removeLast();
        drone.destroy();
        print('Removed drone. Remaining: ${_activeDrones.length}');
      }
    }
  }
  
  void updateHeroSize() {
    heroRadius = 15.0 * DisplayConfig.instance.scaleFactor * totalCharacterSize;
    // Update component size as well
    size = Vector2.all(heroRadius * 2);
  }
  
  void destroyAllDrones() {
    for (final drone in _activeDrones) {
      drone.destroy();
    }
    _activeDrones.clear();
    print('All drones destroyed');
  }
  
  // Clone management system
  bool canActivateClone() {
    return hasCloneProjection && _activeClone == null && health > maxHealth * 0.5;
  }
  
  void activateClone() {
    print('ð¤ Attempting to activate clone...');
    print('   - Has clone projection: ${hasCloneProjection}');
    print('   - No active clone: ${_activeClone == null}');
    print('   - Current health: ${health.toStringAsFixed(1)}/${maxHealth.toStringAsFixed(1)}');
    print('   - Required health: ${(maxHealth * 0.5).toStringAsFixed(1)}');
    
    if (!canActivateClone()) {
      print('â Cannot activate clone: requirements not met');
      return;
    }
    
    // Pay health cost (50% of current health)
    final healthCost = health * 0.5;
    health -= healthCost;
    
    // Spawn clone directly to the right with clear gap
    final cloneOffset = Vector2(80, 0); // Simple fixed offset to the right
    final clonePosition = position + cloneOffset;
    
    print('ð¤ Creating HeroClone at position: (${clonePosition.x}, ${clonePosition.y})');
    _activeClone = HeroClone(owner: this, spawnPosition: clonePosition);
    
    print('ð¤ Adding clone to game...');
    gameRef.add(_activeClone!);
    
    print('â CLONE ACTIVATED! Health cost: ${healthCost.toStringAsFixed(1)}, Clone mounted: ${_activeClone!.isMounted}');
  }
  
  void destroyClone() {
    if (_activeClone != null) {
      _activeClone!.destroy();
      _activeClone = null;
      print('Clone destroyed');
    }
  }
  
  bool get hasActiveClone => _activeClone != null;
  
  // Getter for passive effect stacks (for stats display)
  Map<String, int> get passiveEffectStacks => Map.from(_passiveEffectStacks);
  
  void onCloneDestroyed(HeroClone clone) {
    if (_activeClone == clone) {
      _activeClone = null;
      print('Active clone reference cleared');
    }
  }
  
  @override
  void onRemove() {
    // Clean up display config listener
    if (_displayConfigListener != null) {
      DisplayConfig.instance.removeListener(_displayConfigListener!);
      _displayConfigListener = null;
    }
    super.onRemove();
  }
}

// Visual effect component for abilities
class AbilityVisualEffect extends PositionComponent with HasGameRef<CircleRougeGame> {
  final double effectRange;
  final String shape;
  final Color color;
  
  double lifetime = 0.0;
  static const double totalLifetime = 0.5; // Blink once and disappear
  static const double blinkDuration = 0.25; // Half the lifetime for one blink
  
  AbilityVisualEffect({
    required Vector2 position,
    required this.effectRange,
    required this.shape,
    required this.color,
  }) : super(
    position: position,
    size: Vector2.all(effectRange * 2),
    anchor: Anchor.center,
  );
  
  @override
  void update(double dt) {
    super.update(dt);
    
    lifetime += dt;
    
    // Remove after total lifetime
    if (lifetime >= totalLifetime) {
      removeFromParent();
    }
  }
  
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    
    final center = Offset(size.x / 2, size.y / 2);
    
    // Calculate opacity with blinking effect
    final blinkProgress = (lifetime / blinkDuration) % 1.0;
    final opacity = (sin(blinkProgress * pi * 2) * 0.15 + 0.1).clamp(0.0, 0.25); // 25% max opacity
    
    final paint = Paint()
      ..color = color.withOpacity(opacity)
      ..style = PaintingStyle.fill;
    
    final strokePaint = Paint()
      ..color = color.withOpacity(opacity * 2)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3.0;
    
    // Draw the shape based on type
    switch (shape) {
      case 'square':
        final rect = Rect.fromCenter(
          center: center,
          width: effectRange * 2,
          height: effectRange * 2,
        );
        canvas.drawRect(rect, paint);
        canvas.drawRect(rect, strokePaint);
        break;
      case 'heptagon':
        final path = _createHeptagonPath(center, effectRange);
        canvas.drawPath(path, paint);
        canvas.drawPath(path, strokePaint);
        break;
    }
  }
  
  Path _createHeptagonPath(Offset center, double radius) {
    final path = Path();
    
    for (int i = 0; i < 7; i++) {
      final angle = -90 + (i * 51.42857142857143); // Heptagon angles
      final x = center.dx + radius * cos(angle * pi / 180);
      final y = center.dy + radius * sin(angle * pi / 180);
      if (i == 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.close();
    
    return path;
  }
} 
```

Now let me create a todo list to track these changes and check how the color coding should work for the new item types:

Now let me find where item colors are defined in the shop system:

Perfect! I found the color system. I can see there are two places where item colors are defined:

1. **ShopPanel** (`_getCategoryColors` method) - handles individual item colors based on item ID
2. **ItemDetailCard** (`_getItemCategoryColor` method) - also handles individual item colors based on item ID

I need to update both to use the new type-based system. Let me update the shop panel first:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flame/events.dart';
import 'package:flutter/material.dart';

import '../game/circle_rouge_game.dart';
import '../config/item_config.dart';
import '../config/wave_config.dart';
import 'sound_manager.dart';
import '../config/display_config.dart';
import 'ui/responsive_layout.dart';
import '../config/game_mode_config.dart';
import 'ui/item_detail_card.dart';

class ShopItem {
  final String id;
  final String name;
  final int cost;
  final String description;
  final String icon;
  final void Function() onPurchase;
  
  ShopItem({
    required this.id,
    required this.name,
    required this.cost,
    required this.description,
    required this.icon,
    required this.onPurchase,
  });
  
  factory ShopItem.fromItemData(ItemData itemData, void Function() onPurchase, int scaledCost) {
    return ShopItem(
      id: itemData.id,
      name: itemData.name,
      cost: scaledCost,
      description: itemData.description,
      icon: itemData.icon,
      onPurchase: onPurchase,
    );
  }
}

class ShopPanel extends RectangleComponent with HasGameRef<CircleRougeGame>, TapCallbacks, ResponsiveMixin {
  late List<ShopSlot> itemSlots;
  late RectangleComponent rollButton;
  late TextComponent rollButtonText;
  late TextComponent titleText;
  late TextComponent instructionText;
  late RectangleComponent backgroundGradient;
  late RectangleComponent headerPanel;
  late RectangleComponent footerPanel;
  
  bool isVisible = false;
  int rollCount = 0; // Track number of rolls in this shop session
  
  // Base dimensions for responsive scaling
  static const double basePanelWidth = 715.0;
  static const double basePanelHeight = 550.0;
  static const double baseSlotWidth = 176.0;
  static const double baseSlotHeight = 275.0;
  static const double baseSlotSpacing = 49.5;
  
  ShopPanel() : super(
    size: Vector2(basePanelWidth, basePanelHeight),
    paint: Paint()..color = Colors.transparent,
    position: Vector2(
      (DisplayConfig.instance.arenaWidth - basePanelWidth) / 2,
      (DisplayConfig.instance.arenaHeight - basePanelHeight) / 2,
    ),
    anchor: Anchor.topLeft, // Keep original anchor
  );
  
  /// Get current scaled dimensions
  Vector2 get scaledPanelSize => size;
  double get scaledPanelWidth => scaledPanelSize.x;
  double get scaledPanelHeight => scaledPanelSize.y;
  double get scaledSlotWidth => baseSlotWidth * (scaledPanelWidth / basePanelWidth);
  double get scaledSlotHeight => baseSlotHeight * (scaledPanelHeight / basePanelHeight);
  double get scaledSlotSpacing => baseSlotSpacing * (scaledPanelWidth / basePanelWidth);

  @override
  Future<void> onLoad() async {
    super.onLoad();
    
    // Set up display config listener for simple responsive behavior
    DisplayConfig.instance.addListener(_onDisplayConfigChanged);
    
    _setupVisualComponents();  // Set up background first (lower z-order)
    _setupItemSlots();          // Then add item slots on top
    
    // Populate with initial items after everything is set up
    rollShopItems();
  }
  
  void _setupVisualComponents() {
    // Background with enhanced gradient effect
    backgroundGradient = RectangleComponent(
      size: scaledPanelSize,
      paint: Paint()
        ..shader = const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFF2D2D4A),
            Color(0xFF1E1E3A),
            Color(0xFF151528),
          ],
        ).createShader(Rect.fromLTWH(0, 0, scaledPanelWidth, scaledPanelHeight)),
      position: Vector2.zero(),
    );
    add(backgroundGradient);
    
    // Main border with enhanced glow effect
    final border = RectangleComponent(
      size: Vector2(basePanelWidth, basePanelHeight),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3
        ..color = const Color(0xFF4A9EFF).withOpacity(0.6),
      position: Vector2.zero(),
    );
    add(border);
    
    // Outer glow effect
    final outerGlow = RectangleComponent(
      size: Vector2(basePanelWidth + 10, basePanelHeight + 10),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 8
        ..color = const Color(0xFF4A9EFF).withOpacity(0.1)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 15),
      position: Vector2(-5, -5),
    );
    add(outerGlow);
    
    // Header panel with gradient
    headerPanel = RectangleComponent(
      size: Vector2(basePanelWidth - 20, 99),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF4A9EFF),
            Color(0xFF9C27B0),
          ],
        ).createShader(Rect.fromLTWH(0, 0, basePanelWidth - 20, 99))
        ..color = const Color(0xFF4A9EFF).withOpacity(0.15),
      position: Vector2(10, 10),
    );
    add(headerPanel);
    
    // Header border with glow
    final headerBorder = RectangleComponent(
      size: Vector2(basePanelWidth - 20, 99),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2
        ..color = const Color(0xFF4A9EFF).withOpacity(0.6),
      position: Vector2(10, 10),
    );
    add(headerBorder);
    
    // Title with enhanced styling and shader mask effect
    titleText = TextComponent(
      text: 'MYSTICAL SHOP',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white, // This will be overridden by the gradient
          fontSize: 35.2, // Increased from 32 (10% bigger)
          fontWeight: FontWeight.w900,
          letterSpacing: 3.0,
          shadows: [
            Shadow(
              color: Color(0xFF4A9EFF),
              blurRadius: 15,
            ),
            Shadow(
              color: Color(0xFF9C27B0),
              blurRadius: 10,
            ),
            Shadow(
              color: Colors.black,
              blurRadius: 5,
            ),
          ],
        ),
      ),
      anchor: Anchor.topCenter,
      position: Vector2(scaledPanelWidth / 2, 33 * (scaledPanelHeight / basePanelHeight)), // Back to original approach
    );
    add(titleText);
    
    // Instructions with enhanced styling
    instructionText = TextComponent(
      text: 'Enhance your hero with powerful upgrades',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFFE0E0E0),
          fontSize: 17.6, // Increased from 16 (10% bigger)
          fontWeight: FontWeight.w600,
          letterSpacing: 1.2,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 6,
            ),
            Shadow(
              color: Color(0xFF4A9EFF),
              blurRadius: 2,
            ),
          ],
        ),
      ),
      anchor: Anchor.topCenter,
      position: Vector2(scaledPanelWidth / 2, 77 * (scaledPanelHeight / basePanelHeight)), // Back to original approach
    );
    add(instructionText);
    
    // Item slots will be set up in separate method
    
    // Footer panel with gradient background
    footerPanel = RectangleComponent(
      size: Vector2(scaledPanelWidth - 20 * (scaledPanelWidth / basePanelWidth), 70 * (scaledPanelHeight / basePanelHeight)),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF2D2D4A),
            Color(0xFF1E1E3A),
          ],
        ).createShader(Rect.fromLTWH(0, 0, basePanelWidth - 20, 70))
        ..color = const Color(0xFF2D2D4A).withOpacity(0.6),
      position: Vector2(10, basePanelHeight - 80),
    );
    add(footerPanel);
    
    // Footer border
    final footerBorder = RectangleComponent(
      size: Vector2(basePanelWidth - 20, 70),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2
        ..color = const Color(0xFF4A9EFF).withOpacity(0.3),
      position: Vector2(10, basePanelHeight - 80),
    );
    add(footerBorder);
    
    // Roll button with enhanced gradient styling
    rollButton = RectangleComponent(
      size: Vector2(140, 45),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF2196F3),
            Color(0xFF1976D2),
          ],
        ).createShader(Rect.fromLTWH(0, 0, 140, 45)),
      position: Vector2((basePanelWidth - 140) / 2 - 90, basePanelHeight - 65),
    );
    add(rollButton);
    
    // Roll button glow effect
    final rollButtonGlow = RectangleComponent(
      size: Vector2(140, 45),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3
        ..color = const Color(0xFF2196F3).withOpacity(0.5)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 8),
      position: Vector2((basePanelWidth - 140) / 2 - 90, basePanelHeight - 65),
    );
    add(rollButtonGlow);
    
    rollButtonText = TextComponent(
      text: 'REROLL (10)',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white,
          fontSize: 16,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.5,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 4,
            ),
          ],
        ),
      ),
      anchor: Anchor.center,
      position: Vector2(70, 22.5),
    );
    rollButton.add(rollButtonText);
    
    // Continue button with enhanced gradient styling
    final continueButton = RectangleComponent(
      size: Vector2(140, 45),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF4CAF50),
            Color(0xFF388E3C),
          ],
        ).createShader(Rect.fromLTWH(0, 0, 140, 45)),
      position: Vector2((basePanelWidth - 140) / 2 + 90, basePanelHeight - 65),
    );
    add(continueButton);
    
    // Continue button glow effect
    final continueButtonGlow = RectangleComponent(
      size: Vector2(140, 45),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3
        ..color = const Color(0xFF4CAF50).withOpacity(0.5)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 8),
      position: Vector2((basePanelWidth - 140) / 2 + 90, basePanelHeight - 65),
    );
    add(continueButtonGlow);
    
    final continueButtonText = TextComponent(
      text: 'CONTINUE',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white,
          fontSize: 16,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.5,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 4,
            ),
          ],
        ),
      ),
      anchor: Anchor.center,
      position: Vector2(70, 22.5),
    );
    continueButton.add(continueButtonText);
    
    // Store continue button reference for tap detection
    continueButton.add(Component());
    continueButton.children.register<Component>();
    
    // Initially hidden
    hide();
    
    // Initial items will be populated after onLoad completes
  }
  
  void _setupItemSlots() {
    // Create item slots with responsive positioning
    itemSlots = [];
    final slotsStartX = (scaledPanelWidth - (3 * scaledSlotWidth + 2 * scaledSlotSpacing)) / 2;
    for (int i = 0; i < 3; i++) {
      final slot = ShopSlot(
        position: Vector2(
          slotsStartX + i * (scaledSlotWidth + scaledSlotSpacing),
          121 * (scaledPanelHeight / basePanelHeight), // Scale the Y position too
        ),
      );
      // Update slot size to match scaled dimensions
      slot.size = Vector2(scaledSlotWidth, scaledSlotHeight);
      // Set high priority to ensure slots render on top
      slot.priority = 100;
      itemSlots.add(slot);
      add(slot);
    }
  }
  
  void show() {
    isVisible = true;
    opacity = 1.0;
  }
  
  void hide() {
    isVisible = false;
    opacity = 0.0;
  }
  
  @override
  void onRemove() {
    DisplayConfig.instance.removeListener(_onDisplayConfigChanged);
    super.onRemove();
  }
  
  /// Handle display config changes for responsive behavior
  void _onDisplayConfigChanged(DisplaySettings oldSettings, DisplaySettings newSettings) {
    print('ShopPanel: Display config changed - ${newSettings.arenaWidth.toInt()}x${newSettings.arenaHeight.toInt()}, scale: ${newSettings.scaleFactor.toStringAsFixed(2)}');
    
    // Update panel size and position
    final scaleFactor = newSettings.scaleFactor;
    final newSize = Vector2(basePanelWidth * scaleFactor, basePanelHeight * scaleFactor);
    final newPosition = Vector2(
      (newSettings.arenaWidth - newSize.x) / 2,
      (newSettings.arenaHeight - newSize.y) / 2,
    );
    
    // Only update if there's an actual change to prevent unnecessary refreshes
    if ((size - newSize).length > 1.0 || (position - newPosition).length > 1.0) {
      size = newSize;
      position = newPosition;
      
      print('ShopPanel: Updated - size: ${size.x.toInt()}x${size.y.toInt()}, pos: ${position.x.toInt()},${position.y.toInt()}');
      
      // Refresh child components with new dimensions
      _refreshChildComponents();
    }
  }
  
  // Removed updateResponsiveLayout since we're not using ResponsiveMixin
  
  /// Refresh all child components with current scaled dimensions
  void _refreshChildComponents() {
    // Save current items before refresh
    final List<ShopItem?> currentItems = itemSlots.map((slot) => slot.currentItem).toList();
    
    // Remove and recreate all child components with new scaled dimensions
    removeAll(children.toList());
    _setupVisualComponents();  // Set up background first (lower z-order)
    _setupItemSlots();          // Then add item slots on top
    
    // Restore items to the new slots
    for (int i = 0; i < currentItems.length && i < itemSlots.length; i++) {
      if (currentItems[i] != null) {
        itemSlots[i].setItem(currentItems[i]!);
      }
    }
  }
  
  @override
  bool onTapDown(TapDownEvent event) {
    if (!isVisible) return false;
    
    final localPoint = event.localPosition;
    
    // Check if roll button was tapped - updated for 10% bigger dimensions
    final rollButtonRect = Rect.fromLTWH(
      rollButton.position.x,
      rollButton.position.y,
      154, // Updated from 140
      49.5, // Updated from 45
    );
    
    if (rollButtonRect.contains(Offset(localPoint.x, localPoint.y))) {
      rollShopItems();
      return true;
    }
    
    // Check if continue button was tapped - updated for 10% bigger dimensions
    final continueButtonPosition = Vector2((basePanelWidth - 154) / 2 + 99, basePanelHeight - 71.5); // Updated from 140/90/65
    final continueButtonRect = Rect.fromLTWH(
      continueButtonPosition.x,
      continueButtonPosition.y,
      154, // Updated from 140
      49.5, // Updated from 45
    );
    
    if (continueButtonRect.contains(Offset(localPoint.x, localPoint.y))) {
      closeShop();
      return true;
    }
    
    return false;
  }
  
  void rollShopItems() {
    // Check if all items are sold (free roll)
    final allItemsSold = itemSlots.every((slot) => slot.currentItem == null);
    
    // Calculate roll cost: base cost + roll count (increments by 1 each roll)
    final baseCost = WaveConfig.instance.shopConfig?.rollCost ?? 10;
    final rollCost = allItemsSold ? 0 : (baseCost + rollCount);
    
    // Check if player has enough coins to roll
    if (gameRef.hero.coins < rollCost) {
      return; // Not enough coins to roll
    }
    
    // Spend coins for rolling (if not free)
    if (rollCost > 0) {
      gameRef.hero.spendCoins(rollCost);
      rollCount++; // Increment roll count after successful roll
    }
    
    final availableItems = _getAvailableItems();
    final random = Random();
    
    for (int i = 0; i < 3; i++) {
      if (availableItems.isNotEmpty) {
        final randomItem = availableItems[random.nextInt(availableItems.length)];
        itemSlots[i].setItem(randomItem);
      }
    }
    
    // Update roll button text with next roll cost
    final nextRollCost = baseCost + rollCount;
    rollButtonText.text = 'REROLL ($nextRollCost)';
  }
  
  List<ShopItem> _getAvailableItems() {
    final itemConfig = ItemConfig.instance;
    final shopConfig = WaveConfig.instance.shopConfig;
    List<ShopItem> availableItems = [];
    final random = Random();
    
    for (final itemData in itemConfig.items) {
      // Skip health-related items in 1HP Challenge mode
      if (gameRef.currentGameMode == GameMode.oneHpChallenge) {
        if (itemData.effect.type == 'heal' || 
            itemData.effect.type == 'max_health_increase') {
          continue; // Skip health items in 1HP mode
        }
      }
      
      // Calculate scaled price based on current wave using configuration
      double waveMultiplier = 1.0;
      double randomMultiplier = 1.0;
      
      if (shopConfig != null) {
        waveMultiplier = 1.0 + (shopConfig.waveMultiplier * (gameRef.currentWave - 1));
        randomMultiplier = (1.0 - shopConfig.randomVariance) + (random.nextDouble() * shopConfig.randomVariance * 2);
      } else {
        // Fallback to old hardcoded values
        waveMultiplier = 1.0 + (0.2 * (gameRef.currentWave - 1));
        randomMultiplier = 0.95 + (random.nextDouble() * 0.1);
      }
      
      final scaledCost = (itemData.cost * waveMultiplier * randomMultiplier).round();
      
      // Create dynamic name for ability cooldown reduction based on hero's ability
      if (itemData.id == 'dash_mastery') {
        final heroAbilityName = gameRef.hero.heroData.ability.name;
        availableItems.add(ShopItem(
          id: itemData.id,
          name: '$heroAbilityName Mastery',
          cost: scaledCost,
          description: '-25% ${heroAbilityName} Cooldown',
          icon: itemData.icon,
          onPurchase: () => _applyItemEffect(itemData),
        ));
      } else {
        availableItems.add(ShopItem.fromItemData(itemData, () => _applyItemEffect(itemData), scaledCost));
      }
    }
    
    return availableItems;
  }
  
  void _applyItemEffect(ItemData itemData) {
    switch (itemData.effect.type) {
      case 'heal':
        final healAmount = (gameRef.hero.maxHealth - gameRef.hero.health).clamp(0.0, itemData.effect.value);
        gameRef.hero.heal(healAmount);
        break;
      case 'dash_cooldown_multiplier':
        // Apply ability cooldown reduction
        gameRef.hero.abilityCooldownMultiplier *= itemData.effect.value;
        break;
      case 'max_health_increase':
        gameRef.hero.maxHealth += itemData.effect.value;
        gameRef.hero.health += itemData.effect.value;
        break;
      case 'attack_speed_multiplier':
        gameRef.hero.attackSpeedMultiplier += itemData.effect.value;
        break;
      case 'speed_multiplier':
        gameRef.hero.speedMultiplier += itemData.effect.value;
        break;
      case 'range_multiplier':
        gameRef.hero.rangeMultiplier += itemData.effect.value;
        break;
      // New stackable passive effects
      case 'projectile_count':
      case 'projectile_bounces':
      case 'projectile_size':
      case 'life_steal':
      case 'shield_hp':
      case 'coin_multiplier':
      case 'heal_per_kill':
      case 'crit_chance':
      case 'clone_spawn':
      case 'max_health_boost':
        final maxStacks = itemData.effect.maxStacks ?? 1;
        gameRef.hero.addPassiveEffect(itemData.effect.type, maxStacks);
        // Max health boost only affects max HP, not current HP
        break;
      case 'drone_count':
        final maxStacks = itemData.effect.maxStacks ?? 1;
        gameRef.hero.addPassiveEffect(itemData.effect.type, maxStacks);
        // Update drone count immediately
        gameRef.hero.updateDroneCount();
        break;
      case 'auto_injector':
        final maxStacks = itemData.effect.maxStacks ?? 1;
        gameRef.hero.addPassiveEffect(itemData.effect.type, maxStacks);
        // Auto-injector HP bonus is applied on kill, not on purchase
        break;
      case 'enlarged_caliber':
        final maxStacks = itemData.effect.maxStacks ?? 1;
        gameRef.hero.addPassiveEffect(itemData.effect.type, maxStacks);
        // Update hero size immediately
        gameRef.hero.updateHeroSize();
        break;
      default:
        print('Unknown item effect type: ${itemData.effect.type}');
    }
  }
  
  void onItemPurchased() {
    // Update roll button text based on remaining items
    final allItemsSold = itemSlots.every((slot) => slot.currentItem == null);
    final baseCost = WaveConfig.instance.shopConfig?.rollCost ?? 10;
    final rollCost = allItemsSold ? 0 : (baseCost + rollCount);
    rollButtonText.text = rollCost == 0 ? 'REROLL (FREE)' : 'REROLL ($rollCost)';
    
    // Update affordability of remaining items after purchase
    for (final slot in itemSlots) {
      if (slot.currentItem != null) {
        slot.updateAffordability();
      }
    }
  }
  
  void resetForNewWave() {
    rollCount = 0; // Reset roll count for new shop session
  }
  
  void closeShop() {
    hide();
    gameRef.onShopClosed();
  }
}

class ShopSlot extends RectangleComponent with TapCallbacks, HasGameRef<CircleRougeGame> {
  late TextBoxComponent nameText;
  late TextComponent costText;
  late TextComponent descriptionText;
  late RectangleComponent buyButton;
  late TextComponent buyButtonText;
  late Component itemIcon;
  late RectangleComponent border;
  late RectangleComponent outerGlow;
  late RectangleComponent buyButtonGlow;
  
  ShopItem? currentItem;
  
  ShopSlot({required Vector2 position}) : super(
    size: Vector2(ShopPanel.baseSlotWidth, ShopPanel.baseSlotHeight),
    paint: Paint()..color = Colors.transparent,
    position: position,
  );
  
  @override
  Future<void> onLoad() async {
    super.onLoad();
    
    // Background with enhanced gradient
    final background = RectangleComponent(
      size: Vector2(size.x, size.y),
      paint: Paint()
        ..shader = const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFF3A3A3A),
            Color(0xFF2A2A2A),
            Color(0xFF1A1A1A),
          ],
        ).createShader(Rect.fromLTWH(0, 0, size.x, size.y)),
      position: Vector2.zero(),
    );
    add(background);
    
    // Border with enhanced glow
    border = RectangleComponent(
      size: Vector2(size.x, size.y),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2
        ..color = const Color(0xFF4A9EFF).withOpacity(0.5),
      position: Vector2.zero(),
    );
    add(border);
    
    // Outer glow effect for slots
    outerGlow = RectangleComponent(
      size: Vector2(size.x + 4, size.y + 4),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 6
        ..color = const Color(0xFF4A9EFF).withOpacity(0.1)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 10),
      position: Vector2(-2, -2),
    );
    add(outerGlow);
    
    // Initialize item icon as empty placeholder - will be replaced when item is set
    itemIcon = RectangleComponent(
      size: Vector2(44, 44),
      position: Vector2((size.x - 44) / 2, 22),
      paint: Paint()..color = Colors.transparent,
    );
    add(itemIcon);
    
    // Item name with enhanced styling and line wrapping
    nameText = TextBoxComponent(
      text: '',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFF4A9EFF),
          fontSize: 17.6,
          fontWeight: FontWeight.w900,
          letterSpacing: 1,
          shadows: [
            Shadow(
              color: Color(0xFF4A9EFF),
              blurRadius: 6,
            ),
          ],
        ),
      ),
      align: Anchor.center,
      boxConfig: TextBoxConfig(
        maxWidth: size.x - 10,
        timePerChar: 0.0,
      ),
      anchor: Anchor.topCenter,
      position: Vector2(size.x / 2, 82.5),
    );
    add(nameText);
    
    // Item description with better styling
    descriptionText = TextComponent(
      text: '',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFFE0E0E0),
          fontSize: 13.2,
          fontWeight: FontWeight.w500,
          height: 1.4,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 2,
            ),
          ],
        ),
      ),
      anchor: Anchor.topCenter,
      position: Vector2(size.x / 2, 132),
    );
    add(descriptionText);
    
    // Cost with enhanced styling
    costText = TextComponent(
      text: '',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFFFFEB3B),
          fontSize: 19.8,
          fontWeight: FontWeight.w900,
          letterSpacing: 1,
          shadows: [
            Shadow(
              color: Color(0xFFFFEB3B),
              blurRadius: 8,
            ),
            Shadow(
              color: Colors.black,
              blurRadius: 4,
            ),
          ],
        ),
      ),
      anchor: Anchor.topCenter,
      position: Vector2(size.x / 2, 170.5),
    );
    add(costText);
    
    // Buy button with enhanced gradient styling
    buyButton = RectangleComponent(
      size: Vector2(143, 44),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF4CAF50),
            Color(0xFF388E3C),
          ],
        ).createShader(Rect.fromLTWH(0, 0, 143, 44)),
      position: Vector2((size.x - 143) / 2, size.y - 60.5),
    );
    add(buyButton);
    
    // Buy button glow effect
    buyButtonGlow = RectangleComponent(
      size: Vector2(143, 44),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3
        ..color = const Color(0xFF4CAF50).withOpacity(0.5)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 6),
      position: Vector2((size.x - 143) / 2, size.y - 60.5),
    );
    add(buyButtonGlow);
    
    buyButtonText = TextComponent(
      text: 'PURCHASE',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white,
          fontSize: 15.4,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.2,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 4,
            ),
          ],
        ),
      ),
      anchor: Anchor.center,
      position: Vector2(71.5, 22),
    );
    buyButton.add(buyButtonText);
  }
  
  // Get category colors based on item type
  Map<String, Color> _getCategoryColors(String itemId) {
    // Get item data to check its type
    final itemData = ItemConfig.instance.getItemById(itemId);
    final itemType = itemData?.type ?? 'other';
    
    switch (itemType) {
      case 'health':
        // Green for health items
        return {
          'primary': const Color(0xFF4CAF50),
          'secondary': const Color(0xFF66BB6A),
          'glow': const Color(0xFF4CAF50),
        };
      case 'attack':
        // Red for attack items
        return {
          'primary': const Color(0xFFF44336),
          'secondary': const Color(0xFFE57373),
          'glow': const Color(0xFFF44336),
        };
      case 'ability':
        // Hero color for ability items
        final heroColor = gameRef.hero.heroData.color;
        return {
          'primary': heroColor,
          'secondary': heroColor.withOpacity(0.8),
          'glow': heroColor,
        };
      case 'other':
      default:
        // Blue for other items
        return {
          'primary': const Color(0xFF2196F3),
          'secondary': const Color(0xFF64B5F6),
          'glow': const Color(0xFF2196F3),
        };
    }
  }

  void setItem(ShopItem item) async {
    currentItem = item;
    final colors = _getCategoryColors(item.id);
    
    nameText.text = item.name.toUpperCase();
    descriptionText.text = item.description;
    costText.text = '${item.cost} COINS';
    
    // Replace the current icon with a sprite-based icon
    if (itemIcon.isMounted) {
      itemIcon.removeFromParent();
    }
    
    try {
      // Try to load the actual item icon sprite
      final sprite = await Sprite.load(item.icon);
      itemIcon = SpriteComponent(
        sprite: sprite,
        size: Vector2(44, 44),
        position: Vector2((size.x - 44) / 2, 22),
        anchor: Anchor.topLeft,
      );
    } catch (e) {
      print('Could not load item icon: ${item.icon}, using colored rectangle fallback');
      // Fallback to colored rectangle with category color
      itemIcon = RectangleComponent(
        size: Vector2(44, 44),
        position: Vector2((size.x - 44) / 2, 22),
        paint: Paint()..color = colors['primary']!,
      );
    }
    
    add(itemIcon);
    
    // Update name text color to match category
    nameText.textRenderer = TextPaint(
      style: TextStyle(
        color: colors['primary']!,
        fontSize: 17.6,
        fontWeight: FontWeight.w900,
        letterSpacing: 1,
        shadows: [
          Shadow(
            color: colors['glow']!,
            blurRadius: 6,
          ),
        ],
      ),
    );
    
    // Update border and glow colors to match category
    border.paint.color = colors['primary']!.withOpacity(0.6);
    outerGlow.paint.color = colors['glow']!.withOpacity(0.15);
    
    // Update buy button styling based on affordability and category
    if (gameRef.hero.coins >= item.cost) {
      // Update buy button gradient with category colors
      buyButton.paint.shader = LinearGradient(
        colors: [
          colors['primary']!,
          colors['secondary']!,
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = colors['glow']!.withOpacity(0.5);
      buyButtonText.text = 'PURCHASE';
    } else {
      // Grey for unaffordable items
      buyButton.paint.shader = const LinearGradient(
        colors: [
          Color(0xFF757575),
          Color(0xFF616161),
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = const Color(0xFF757575).withOpacity(0.3);
      buyButtonText.text = 'TOO EXPENSIVE';
      border.paint.color = const Color(0xFFF44336).withOpacity(0.4);
    }
  }
  
  @override
  bool onTapDown(TapDownEvent event) {
    if (currentItem == null) return false;
    
    final localPoint = event.localPosition;
    
    // Check if buy button was tapped
    if (buyButton.containsLocalPoint(localPoint - buyButton.position)) {
      attemptPurchase();
      return true;
    }
    
    // Check if item info area was tapped (anywhere except buy button)
    if (localPoint.y < buyButton.position.y) {
      showItemDetails();
      return true;
    }
    
    return false;
  }
  
  void showItemDetails() {
    if (currentItem == null) return;
    
    final detailCard = ItemDetailCard(
      item: currentItem!,
      onClose: () {
        // Detail card handles its own removal
      },
    );
    
    // Add to the game at a high priority to appear on top
    gameRef.add(detailCard);
    
    // Play UI sound effect
    // SoundManager().playUICardOpenSound();
  }
  
  void attemptPurchase() {
    if (currentItem == null) return;
    
    if (gameRef.hero.coins >= currentItem!.cost) {
      gameRef.hero.spendCoins(currentItem!.cost);
      currentItem!.onPurchase();
      
      // Play purchase sound effect
      SoundManager().playPurchaseSound();
      
      // Clear this slot with enhanced sold styling
      currentItem = null;
      nameText.text = 'SOLD';
      nameText.textRenderer = TextPaint(
        style: const TextStyle(
          color: Color(0xFF4CAF50),
          fontSize: 17.6,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.5,
          shadows: [
            Shadow(
              color: Color(0xFF4CAF50),
              blurRadius: 8,
            ),
            Shadow(
              color: Colors.black,
              blurRadius: 3,
            ),
          ],
        ),
      );
      descriptionText.text = 'Item purchased successfully!';
      descriptionText.textRenderer = TextPaint(
        style: const TextStyle(
          color: Color(0xFF4CAF50),
          fontSize: 13.2,
          fontWeight: FontWeight.w500,
          height: 1.4,
        ),
      );
      costText.text = '';
      
      // Update buy button to sold out styling
      buyButton.paint.shader = const LinearGradient(
        colors: [
          Color(0xFF757575),
          Color(0xFF616161),
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = const Color(0xFF757575).withOpacity(0.3);
      buyButtonText.text = 'SOLD OUT';
      
      // Update border and glow to success green
      border.paint.color = const Color(0xFF4CAF50).withOpacity(0.8);
      outerGlow.paint.color = const Color(0xFF4CAF50).withOpacity(0.2);
      
      // Clear the item icon - handle both SpriteComponent and RectangleComponent types
      if (itemIcon.isMounted) {
        itemIcon.removeFromParent();
      }
      
      // Add transparent placeholder
      itemIcon = RectangleComponent(
        size: Vector2(44, 44),
        position: Vector2((size.x - 44) / 2, 22),
        paint: Paint()..color = Colors.transparent,
      );
      add(itemIcon);
      
      // Update parent shop immediately
      if (parent is ShopPanel) {
        (parent as ShopPanel).onItemPurchased();
      }
    }
  }
  
  void updateAffordability() {
    if (currentItem == null) return;
    
    final colors = _getCategoryColors(currentItem!.id);
    
    // Update buy button styling based on current affordability
    if (gameRef.hero.coins >= currentItem!.cost) {
      // Update buy button gradient with category colors
      buyButton.paint.shader = LinearGradient(
        colors: [
          colors['primary']!,
          colors['secondary']!,
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = colors['glow']!.withOpacity(0.5);
      buyButtonText.text = 'PURCHASE';
      border.paint.color = colors['primary']!.withOpacity(0.6);
    } else {
      // Grey for unaffordable items
      buyButton.paint.shader = const LinearGradient(
        colors: [
          Color(0xFF757575),
          Color(0xFF616161),
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = const Color(0xFF757575).withOpacity(0.3);
      buyButtonText.text = 'TOO EXPENSIVE';
      border.paint.color = const Color(0xFFF44336).withOpacity(0.4);
    }
  }
} 
```

Now let me update the ItemDetailCard as well:

```dart
import 'package:flame/components.dart';
import 'package:flame/events.dart';
import 'package:flutter/material.dart';

import '../../game/circle_rouge_game.dart';
import '../../config/display_config.dart';
import '../shop_panel.dart';

class ItemDetailCard extends RectangleComponent with HasGameRef<CircleRougeGame>, TapCallbacks {
  final ShopItem item;
  final VoidCallback onClose;
  
  // Visual components
  late RectangleComponent background;
  late RectangleComponent border;
  late TextComponent titleText;
  late TextComponent descriptionText;
  late TextComponent costText;
  late TextComponent stackInfoText;
  late TextComponent instructionText;
  
  // Animation properties
  double animationTime = 0.0;
  static const double animationDuration = 0.3;
  bool isClosing = false;
  
  ItemDetailCard({
    required this.item,
    required this.onClose,
  }) : super(
    anchor: Anchor.center,
  ) {
    final screenWidth = DisplayConfig.instance.settings?.windowWidth ?? 800.0;
    final screenHeight = DisplayConfig.instance.settings?.windowHeight ?? 600.0;
    
    // Card dimensions
    final cardWidth = (screenWidth * 0.6).clamp(300.0, 500.0);
    final cardHeight = (screenHeight * 0.4).clamp(200.0, 300.0);
    
    size = Vector2(cardWidth, cardHeight);
    position = Vector2(screenWidth / 2, screenHeight / 2);
    
    _setupVisualComponents();
  }
  
  void _setupVisualComponents() {
    // Background with semi-transparent overlay
    background = RectangleComponent(
      size: size,
      paint: Paint()
        ..color = const Color(0xFF1A1A1A).withOpacity(0.95)
        ..style = PaintingStyle.fill,
    );
    add(background);
    
    // Border with item category color
    final borderColor = _getItemCategoryColor();
    border = RectangleComponent(
      size: size,
      paint: Paint()
        ..color = borderColor
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0,
    );
    add(border);
    
    // Title text
    titleText = TextComponent(
      text: item.name.toUpperCase(),
      textRenderer: TextPaint(
        style: TextStyle(
          color: borderColor,
          fontSize: 24,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.5,
        ),
      ),
      position: Vector2(size.x / 2, 40),
      anchor: Anchor.center,
    );
    add(titleText);
    
    // Cost text
    costText = TextComponent(
      text: '${item.cost} COINS',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFFFFD700), // Gold color
          fontSize: 20,
          fontWeight: FontWeight.bold,
        ),
      ),
      position: Vector2(size.x / 2, 70),
      anchor: Anchor.center,
    );
    add(costText);
    
    // Description text (word-wrapped)
    final wrappedDescription = _wrapText(item.description, 45);
    descriptionText = TextComponent(
      text: wrappedDescription,
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white,
          fontSize: 16,
          height: 1.4,
        ),
      ),
      position: Vector2(size.x / 2, 110),
      anchor: Anchor.center,
    );
    add(descriptionText);
    
    // Stack information (if applicable)
    final stackInfo = _getStackInfo();
    if (stackInfo.isNotEmpty) {
      stackInfoText = TextComponent(
        text: stackInfo,
        textRenderer: TextPaint(
          style: const TextStyle(
            color: Color(0xFF88FF88), // Light green
            fontSize: 14,
            fontStyle: FontStyle.italic,
          ),
        ),
        position: Vector2(size.x / 2, size.y - 70),
        anchor: Anchor.center,
      );
      add(stackInfoText);
    }
    
    // Instruction text
    instructionText = TextComponent(
      text: 'TAP ANYWHERE TO CLOSE',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFF888888),
          fontSize: 12,
          letterSpacing: 1.0,
        ),
      ),
      position: Vector2(size.x / 2, size.y - 30),
      anchor: Anchor.center,
    );
    add(instructionText);
  }
  
  Color _getItemCategoryColor() {
    // Determine color based on item type
    switch (item.type) {
      case 'health':
        return const Color(0xFF4CAF50); // Green
      case 'attack':
        return const Color(0xFFF44336); // Red
      case 'ability':
        // Use hero color for ability items
        return gameRef.hero.heroData.color;
      case 'other':
      default:
        return const Color(0xFF2196F3); // Blue
    }
  }
  
  String _getStackInfo() {
    final hero = gameRef.hero;
    
    switch (item.id) {
      case 'spread_master':
        final current = hero.getPassiveEffectStacks('projectile_count');
        return 'Current: +$current projectiles (Max: +9)';
      
      case 'bouncing_bullets':
        final current = hero.getPassiveEffectStacks('projectile_bounces');
        return 'Current: +$current bounces (Max: +3)';
      
      case 'drone_wingman':
        final current = hero.getPassiveEffectStacks('drone_count');
        return 'Current: $current drones (Max: 3)';
      
      case 'enlarged_caliber':
        final current = hero.getPassiveEffectStacks('projectile_size');
        final percentage = (current * 10);
        return 'Current: +$percentage% size (Max: +100%)';
      
      case 'vampiric_coating':
        final current = hero.getPassiveEffectStacks('life_steal');
        final percentage = (current * 5);
        return 'Current: +$percentage% life steal (Max: +20%)';
      
      case 'armor_plating':
        final current = hero.getPassiveEffectStacks('shield_hp');
        final shieldHP = current * 5;
        return 'Current: +$shieldHP shield HP (Max: +100)';
      
      case 'coin_magnet':
        final current = hero.getPassiveEffectStacks('coin_multiplier');
        final percentage = (current * 20);
        return 'Current: +$percentage% coin earn (Max: +100%)';
      
      case 'auto_injector':
        final current = hero.getPassiveEffectStacks('heal_per_kill');
        final healAmount = current * 2;
        return 'Current: +$healAmount HP per kill (Max: +10)';
      
      case 'critical_striker':
        final current = hero.getPassiveEffectStacks('crit_chance');
        final percentage = (current * 2);
        return 'Current: +$percentage% crit chance (Max: +10%)';
      
      case 'clone_projection':
        final hasClone = hero.hasCloneProjection;
        return hasClone ? 'Clone Projection: Available (Press C)' : 'Not owned';
      
      default:
        return '';
    }
  }
  
  String _wrapText(String text, int maxLineLength) {
    final words = text.split(' ');
    final lines = <String>[];
    String currentLine = '';
    
    for (final word in words) {
      if (currentLine.isEmpty) {
        currentLine = word;
      } else if ((currentLine + ' ' + word).length <= maxLineLength) {
        currentLine += ' ' + word;
      } else {
        lines.add(currentLine);
        currentLine = word;
      }
    }
    
    if (currentLine.isNotEmpty) {
      lines.add(currentLine);
    }
    
    return lines.join('\n');
  }
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Handle animation
    if (!isClosing) {
      animationTime += dt;
      if (animationTime < animationDuration) {
        final progress = animationTime / animationDuration;
        final easeProgress = _easeOutCubic(progress);
        
        // Scale animation
        scale = Vector2.all(easeProgress);
        
        // Fade in
        final opacity = easeProgress;
        background.paint.color = const Color(0xFF1A1A1A).withOpacity(0.95 * opacity);
        border.paint.color = _getItemCategoryColor().withOpacity(opacity);
      } else {
        scale = Vector2.all(1.0);
      }
    } else {
      animationTime -= dt * 3; // Faster closing animation
      if (animationTime <= 0) {
        removeFromParent();
        return;
      }
      
      final progress = animationTime / animationDuration;
      scale = Vector2.all(progress);
      
      // Fade out
      final opacity = progress;
      background.paint.color = const Color(0xFF1A1A1A).withOpacity(0.95 * opacity);
      border.paint.color = _getItemCategoryColor().withOpacity(opacity);
    }
  }
  
  double _easeOutCubic(double t) {
    return 1 - pow(1 - t, 3);
  }
  
  @override
  bool onTapDown(TapDownEvent event) {
    close();
    return true;
  }
  
  void close() {
    if (!isClosing) {
      isClosing = true;
      onClose();
    }
  }
  
  double pow(double base, int exponent) {
    double result = 1.0;
    for (int i = 0; i < exponent; i++) {
      result *= base;
    }
    return result;
  }
}

```

Now let me mark the final todo as completed and check for any linter errors:

I need to check the ShopItem class structure to see how to access the item type. Let me check the ShopItem definition:

I can see that ShopItem doesn't have a `type` field - it only has basic properties like `id`, `name`, `cost`, etc. I need to get the item type by looking up the ItemData using the item ID. Let me fix this:

```dart
import 'package:flame/components.dart';
import 'package:flame/events.dart';
import 'package:flutter/material.dart';

import '../../game/circle_rouge_game.dart';
import '../../config/display_config.dart';
import '../shop_panel.dart';

class ItemDetailCard extends RectangleComponent with HasGameRef<CircleRougeGame>, TapCallbacks {
  final ShopItem item;
  final VoidCallback onClose;
  
  // Visual components
  late RectangleComponent background;
  late RectangleComponent border;
  late TextComponent titleText;
  late TextComponent descriptionText;
  late TextComponent costText;
  late TextComponent stackInfoText;
  late TextComponent instructionText;
  
  // Animation properties
  double animationTime = 0.0;
  static const double animationDuration = 0.3;
  bool isClosing = false;
  
  ItemDetailCard({
    required this.item,
    required this.onClose,
  }) : super(
    anchor: Anchor.center,
  ) {
    final screenWidth = DisplayConfig.instance.settings?.windowWidth ?? 800.0;
    final screenHeight = DisplayConfig.instance.settings?.windowHeight ?? 600.0;
    
    // Card dimensions
    final cardWidth = (screenWidth * 0.6).clamp(300.0, 500.0);
    final cardHeight = (screenHeight * 0.4).clamp(200.0, 300.0);
    
    size = Vector2(cardWidth, cardHeight);
    position = Vector2(screenWidth / 2, screenHeight / 2);
    
    _setupVisualComponents();
  }
  
  void _setupVisualComponents() {
    // Background with semi-transparent overlay
    background = RectangleComponent(
      size: size,
      paint: Paint()
        ..color = const Color(0xFF1A1A1A).withOpacity(0.95)
        ..style = PaintingStyle.fill,
    );
    add(background);
    
    // Border with item category color
    final borderColor = _getItemCategoryColor();
    border = RectangleComponent(
      size: size,
      paint: Paint()
        ..color = borderColor
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0,
    );
    add(border);
    
    // Title text
    titleText = TextComponent(
      text: item.name.toUpperCase(),
      textRenderer: TextPaint(
        style: TextStyle(
          color: borderColor,
          fontSize: 24,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.5,
        ),
      ),
      position: Vector2(size.x / 2, 40),
      anchor: Anchor.center,
    );
    add(titleText);
    
    // Cost text
    costText = TextComponent(
      text: '${item.cost} COINS',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFFFFD700), // Gold color
          fontSize: 20,
          fontWeight: FontWeight.bold,
        ),
      ),
      position: Vector2(size.x / 2, 70),
      anchor: Anchor.center,
    );
    add(costText);
    
    // Description text (word-wrapped)
    final wrappedDescription = _wrapText(item.description, 45);
    descriptionText = TextComponent(
      text: wrappedDescription,
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white,
          fontSize: 16,
          height: 1.4,
        ),
      ),
      position: Vector2(size.x / 2, 110),
      anchor: Anchor.center,
    );
    add(descriptionText);
    
    // Stack information (if applicable)
    final stackInfo = _getStackInfo();
    if (stackInfo.isNotEmpty) {
      stackInfoText = TextComponent(
        text: stackInfo,
        textRenderer: TextPaint(
          style: const TextStyle(
            color: Color(0xFF88FF88), // Light green
            fontSize: 14,
            fontStyle: FontStyle.italic,
          ),
        ),
        position: Vector2(size.x / 2, size.y - 70),
        anchor: Anchor.center,
      );
      add(stackInfoText);
    }
    
    // Instruction text
    instructionText = TextComponent(
      text: 'TAP ANYWHERE TO CLOSE',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFF888888),
          fontSize: 12,
          letterSpacing: 1.0,
        ),
      ),
      position: Vector2(size.x / 2, size.y - 30),
      anchor: Anchor.center,
    );
    add(instructionText);
  }
  
  Color _getItemCategoryColor() {
    // Get item data to check its type
    final itemData = ItemConfig.instance.getItemById(item.id);
    final itemType = itemData?.type ?? 'other';
    
    // Determine color based on item type
    switch (itemType) {
      case 'health':
        return const Color(0xFF4CAF50); // Green
      case 'attack':
        return const Color(0xFFF44336); // Red
      case 'ability':
        // Use hero color for ability items
        return gameRef.hero.heroData.color;
      case 'other':
      default:
        return const Color(0xFF2196F3); // Blue
    }
  }
  
  String _getStackInfo() {
    final hero = gameRef.hero;
    
    switch (item.id) {
      case 'spread_master':
        final current = hero.getPassiveEffectStacks('projectile_count');
        return 'Current: +$current projectiles (Max: +9)';
      
      case 'bouncing_bullets':
        final current = hero.getPassiveEffectStacks('projectile_bounces');
        return 'Current: +$current bounces (Max: +3)';
      
      case 'drone_wingman':
        final current = hero.getPassiveEffectStacks('drone_count');
        return 'Current: $current drones (Max: 3)';
      
      case 'enlarged_caliber':
        final current = hero.getPassiveEffectStacks('projectile_size');
        final percentage = (current * 10);
        return 'Current: +$percentage% size (Max: +100%)';
      
      case 'vampiric_coating':
        final current = hero.getPassiveEffectStacks('life_steal');
        final percentage = (current * 5);
        return 'Current: +$percentage% life steal (Max: +20%)';
      
      case 'armor_plating':
        final current = hero.getPassiveEffectStacks('shield_hp');
        final shieldHP = current * 5;
        return 'Current: +$shieldHP shield HP (Max: +100)';
      
      case 'coin_magnet':
        final current = hero.getPassiveEffectStacks('coin_multiplier');
        final percentage = (current * 20);
        return 'Current: +$percentage% coin earn (Max: +100%)';
      
      case 'auto_injector':
        final current = hero.getPassiveEffectStacks('heal_per_kill');
        final healAmount = current * 2;
        return 'Current: +$healAmount HP per kill (Max: +10)';
      
      case 'critical_striker':
        final current = hero.getPassiveEffectStacks('crit_chance');
        final percentage = (current * 2);
        return 'Current: +$percentage% crit chance (Max: +10%)';
      
      case 'clone_projection':
        final hasClone = hero.hasCloneProjection;
        return hasClone ? 'Clone Projection: Available (Press C)' : 'Not owned';
      
      default:
        return '';
    }
  }
  
  String _wrapText(String text, int maxLineLength) {
    final words = text.split(' ');
    final lines = <String>[];
    String currentLine = '';
    
    for (final word in words) {
      if (currentLine.isEmpty) {
        currentLine = word;
      } else if ((currentLine + ' ' + word).length <= maxLineLength) {
        currentLine += ' ' + word;
      } else {
        lines.add(currentLine);
        currentLine = word;
      }
    }
    
    if (currentLine.isNotEmpty) {
      lines.add(currentLine);
    }
    
    return lines.join('\n');
  }
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Handle animation
    if (!isClosing) {
      animationTime += dt;
      if (animationTime < animationDuration) {
        final progress = animationTime / animationDuration;
        final easeProgress = _easeOutCubic(progress);
        
        // Scale animation
        scale = Vector2.all(easeProgress);
        
        // Fade in
        final opacity = easeProgress;
        background.paint.color = const Color(0xFF1A1A1A).withOpacity(0.95 * opacity);
        border.paint.color = _getItemCategoryColor().withOpacity(opacity);
      } else {
        scale = Vector2.all(1.0);
      }
    } else {
      animationTime -= dt * 3; // Faster closing animation
      if (animationTime <= 0) {
        removeFromParent();
        return;
      }
      
      final progress = animationTime / animationDuration;
      scale = Vector2.all(progress);
      
      // Fade out
      final opacity = progress;
      background.paint.color = const Color(0xFF1A1A1A).withOpacity(0.95 * opacity);
      border.paint.color = _getItemCategoryColor().withOpacity(opacity);
    }
  }
  
  double _easeOutCubic(double t) {
    return 1 - pow(1 - t, 3);
  }
  
  @override
  bool onTapDown(TapDownEvent event) {
    close();
    return true;
  }
  
  void close() {
    if (!isClosing) {
      isClosing = true;
      onClose();
    }
  }
  
  double pow(double base, int exponent) {
    double result = 1.0;
    for (int i = 0; i < exponent; i++) {
      result *= base;
    }
    return result;
  }
}

```

I also need to add the ItemConfig import to the ItemDetailCard:

```dart
import 'package:flame/components.dart';
import 'package:flame/events.dart';
import 'package:flutter/material.dart';

import '../../game/circle_rouge_game.dart';
import '../../config/display_config.dart';
import '../../config/item_config.dart';
import '../shop_panel.dart';

class ItemDetailCard extends RectangleComponent with HasGameRef<CircleRougeGame>, TapCallbacks {
  final ShopItem item;
  final VoidCallback onClose;
  
  // Visual components
  late RectangleComponent background;
  late RectangleComponent border;
  late TextComponent titleText;
  late TextComponent descriptionText;
  late TextComponent costText;
  late TextComponent stackInfoText;
  late TextComponent instructionText;
  
  // Animation properties
  double animationTime = 0.0;
  static const double animationDuration = 0.3;
  bool isClosing = false;
  
  ItemDetailCard({
    required this.item,
    required this.onClose,
  }) : super(
    anchor: Anchor.center,
  ) {
    final screenWidth = DisplayConfig.instance.settings?.windowWidth ?? 800.0;
    final screenHeight = DisplayConfig.instance.settings?.windowHeight ?? 600.0;
    
    // Card dimensions
    final cardWidth = (screenWidth * 0.6).clamp(300.0, 500.0);
    final cardHeight = (screenHeight * 0.4).clamp(200.0, 300.0);
    
    size = Vector2(cardWidth, cardHeight);
    position = Vector2(screenWidth / 2, screenHeight / 2);
    
    _setupVisualComponents();
  }
  
  void _setupVisualComponents() {
    // Background with semi-transparent overlay
    background = RectangleComponent(
      size: size,
      paint: Paint()
        ..color = const Color(0xFF1A1A1A).withOpacity(0.95)
        ..style = PaintingStyle.fill,
    );
    add(background);
    
    // Border with item category color
    final borderColor = _getItemCategoryColor();
    border = RectangleComponent(
      size: size,
      paint: Paint()
        ..color = borderColor
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0,
    );
    add(border);
    
    // Title text
    titleText = TextComponent(
      text: item.name.toUpperCase(),
      textRenderer: TextPaint(
        style: TextStyle(
          color: borderColor,
          fontSize: 24,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.5,
        ),
      ),
      position: Vector2(size.x / 2, 40),
      anchor: Anchor.center,
    );
    add(titleText);
    
    // Cost text
    costText = TextComponent(
      text: '${item.cost} COINS',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFFFFD700), // Gold color
          fontSize: 20,
          fontWeight: FontWeight.bold,
        ),
      ),
      position: Vector2(size.x / 2, 70),
      anchor: Anchor.center,
    );
    add(costText);
    
    // Description text (word-wrapped)
    final wrappedDescription = _wrapText(item.description, 45);
    descriptionText = TextComponent(
      text: wrappedDescription,
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white,
          fontSize: 16,
          height: 1.4,
        ),
      ),
      position: Vector2(size.x / 2, 110),
      anchor: Anchor.center,
    );
    add(descriptionText);
    
    // Stack information (if applicable)
    final stackInfo = _getStackInfo();
    if (stackInfo.isNotEmpty) {
      stackInfoText = TextComponent(
        text: stackInfo,
        textRenderer: TextPaint(
          style: const TextStyle(
            color: Color(0xFF88FF88), // Light green
            fontSize: 14,
            fontStyle: FontStyle.italic,
          ),
        ),
        position: Vector2(size.x / 2, size.y - 70),
        anchor: Anchor.center,
      );
      add(stackInfoText);
    }
    
    // Instruction text
    instructionText = TextComponent(
      text: 'TAP ANYWHERE TO CLOSE',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFF888888),
          fontSize: 12,
          letterSpacing: 1.0,
        ),
      ),
      position: Vector2(size.x / 2, size.y - 30),
      anchor: Anchor.center,
    );
    add(instructionText);
  }
  
  Color _getItemCategoryColor() {
    // Get item data to check its type
    final itemData = ItemConfig.instance.getItemById(item.id);
    final itemType = itemData?.type ?? 'other';
    
    // Determine color based on item type
    switch (itemType) {
      case 'health':
        return const Color(0xFF4CAF50); // Green
      case 'attack':
        return const Color(0xFFF44336); // Red
      case 'ability':
        // Use hero color for ability items
        return gameRef.hero.heroData.color;
      case 'other':
      default:
        return const Color(0xFF2196F3); // Blue
    }
  }
  
  String _getStackInfo() {
    final hero = gameRef.hero;
    
    switch (item.id) {
      case 'spread_master':
        final current = hero.getPassiveEffectStacks('projectile_count');
        return 'Current: +$current projectiles (Max: +9)';
      
      case 'bouncing_bullets':
        final current = hero.getPassiveEffectStacks('projectile_bounces');
        return 'Current: +$current bounces (Max: +3)';
      
      case 'drone_wingman':
        final current = hero.getPassiveEffectStacks('drone_count');
        return 'Current: $current drones (Max: 3)';
      
      case 'enlarged_caliber':
        final current = hero.getPassiveEffectStacks('projectile_size');
        final percentage = (current * 10);
        return 'Current: +$percentage% size (Max: +100%)';
      
      case 'vampiric_coating':
        final current = hero.getPassiveEffectStacks('life_steal');
        final percentage = (current * 5);
        return 'Current: +$percentage% life steal (Max: +20%)';
      
      case 'armor_plating':
        final current = hero.getPassiveEffectStacks('shield_hp');
        final shieldHP = current * 5;
        return 'Current: +$shieldHP shield HP (Max: +100)';
      
      case 'coin_magnet':
        final current = hero.getPassiveEffectStacks('coin_multiplier');
        final percentage = (current * 20);
        return 'Current: +$percentage% coin earn (Max: +100%)';
      
      case 'auto_injector':
        final current = hero.getPassiveEffectStacks('heal_per_kill');
        final healAmount = current * 2;
        return 'Current: +$healAmount HP per kill (Max: +10)';
      
      case 'critical_striker':
        final current = hero.getPassiveEffectStacks('crit_chance');
        final percentage = (current * 2);
        return 'Current: +$percentage% crit chance (Max: +10%)';
      
      case 'clone_projection':
        final hasClone = hero.hasCloneProjection;
        return hasClone ? 'Clone Projection: Available (Press C)' : 'Not owned';
      
      default:
        return '';
    }
  }
  
  String _wrapText(String text, int maxLineLength) {
    final words = text.split(' ');
    final lines = <String>[];
    String currentLine = '';
    
    for (final word in words) {
      if (currentLine.isEmpty) {
        currentLine = word;
      } else if ((currentLine + ' ' + word).length <= maxLineLength) {
        currentLine += ' ' + word;
      } else {
        lines.add(currentLine);
        currentLine = word;
      }
    }
    
    if (currentLine.isNotEmpty) {
      lines.add(currentLine);
    }
    
    return lines.join('\n');
  }
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Handle animation
    if (!isClosing) {
      animationTime += dt;
      if (animationTime < animationDuration) {
        final progress = animationTime / animationDuration;
        final easeProgress = _easeOutCubic(progress);
        
        // Scale animation
        scale = Vector2.all(easeProgress);
        
        // Fade in
        final opacity = easeProgress;
        background.paint.color = const Color(0xFF1A1A1A).withOpacity(0.95 * opacity);
        border.paint.color = _getItemCategoryColor().withOpacity(opacity);
      } else {
        scale = Vector2.all(1.0);
      }
    } else {
      animationTime -= dt * 3; // Faster closing animation
      if (animationTime <= 0) {
        removeFromParent();
        return;
      }
      
      final progress = animationTime / animationDuration;
      scale = Vector2.all(progress);
      
      // Fade out
      final opacity = progress;
      background.paint.color = const Color(0xFF1A1A1A).withOpacity(0.95 * opacity);
      border.paint.color = _getItemCategoryColor().withOpacity(opacity);
    }
  }
  
  double _easeOutCubic(double t) {
    return 1 - pow(1 - t, 3);
  }
  
  @override
  bool onTapDown(TapDownEvent event) {
    close();
    return true;
  }
  
  void close() {
    if (!isClosing) {
      isClosing = true;
      onClose();
    }
  }
  
  double pow(double base, int exponent) {
    double result = 1.0;
    for (int i = 0; i < exponent; i++) {
      result *= base;
    }
    return result;
  }
}

```

Now let me check for linter errors:

Perfect! Now let me provide a summary of all the changes I've made to address the user's concerns:

## Summary of Changes

### â Fixed Ability Size Scaling for All Heroes

**Problem**: Ability size (`totalAbilitySize`) was only applied to projectile-based abilities (Triangle, Pentagon) but not to area/range-based abilities.

**Solution**: Updated all hero abilities to use both `rangeMultiplier` (from Extended Reach) AND `totalAbilitySize` (from Enlarged Caliber):

1. **Circle Hero (Dash Damage)**: Dash distance now scales with both range and ability size
2. **Square Hero (Area Stun)**: Stun area now scales with both range and ability size  
3. **Hexagon Hero (Area Field)**: Hex field radius now scales with both range and ability size
4. **Heptagon Hero (Resonance Knockback)**: Range and knockback distance now scale with both range and ability size
5. **Triangle Hero (Piercing Shot)**: â Already using ability size correctly
6. **Pentagon Hero (Radial Burst)**: â Already using ability size correctly

**Formula**: `baseRange * rangeMultiplier * totalAbilitySize`

This means:
- **Extended Reach** affects range/distance for all abilities
- **Enlarged Caliber** affects size/area for all abilities
- Both work together multiplicatively

### â Fixed Items.yaml Issues

**Problem**: Extended Reach had incorrect cost and type values.

**Solution**: 
- Fixed `cost: ability` â `cost: 150`
- Fixed `type: upgrade` â `type: ability`

### â Implemented New Color Coding System

**Problem**: Old color system was based on individual item IDs rather than item types.

**Solution**: Updated both `ShopPanel` and `ItemDetailCard` to use the new type-based color system:

- **`health` type** â **Green** (`#4CAF50`)
- **`ability` type** â **Hero Color** (dynamic based on selected hero)
- **`attack` type** â **Red** (`#F44336`) 
- **`other` type** â **Blue** (`#2196F3`)

**Implementation**: Both color systems now:
1. Get the `ItemData` using `ItemConfig.instance.getItemById(itemId)`
2. Extract the `type` field from the item data
3. Apply colors based on the type rather than hardcoded item IDs

This makes the system much more maintainable and consistent. New items will automatically get the correct colors based on their configured type, and ability items will dynamically match the hero's color scheme.

### Current Item Type Distribution:

- **Health**: `health_potion`, `max_health_up`, `vampiric_coating`, `auto_injector`
- **Attack**: `attack_speed_up`, `spread_master`, `bouncing_bullets`, `critical_striker`
- **Ability**: `dash_mastery`, `extended_reach`
- **Other**: `speed_boost`, `drone_wingman`, `enlarged_caliber`, `coin_magnet`

The color coding will now work consistently across all shop interfaces and provide better visual organization for players.

---

**User**

- item text color should also follow the border

---

**Cursor**

I need to check where item text colors are defined and make sure they follow the same color system as the borders. Let me examine the current text color implementations.

I can see the issue! Looking at the shop panel code, I can see that:

1. **Name text color** is already being updated to match the category colors (line 914-927) â
2. **Cost text color** is NOT being updated - it stays at the default color
3. **Description text color** is NOT being updated - it stays at the default grey

Let me also check the ItemDetailCard to see what text colors need to be updated there. Let me examine the cost text setup:

Now let me check the ItemDetailCard text colors:

Let me search more broadly for text components in the ItemDetailCard:

Perfect! Now I can see all the text components that need to be updated. Let me create a todo and fix both the shop panel and item detail card:

First, let me update the shop panel to make the cost text color match the category colors:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flame/events.dart';
import 'package:flutter/material.dart';

import '../game/circle_rouge_game.dart';
import '../config/item_config.dart';
import '../config/wave_config.dart';
import 'sound_manager.dart';
import '../config/display_config.dart';
import 'ui/responsive_layout.dart';
import '../config/game_mode_config.dart';
import 'ui/item_detail_card.dart';

class ShopItem {
  final String id;
  final String name;
  final int cost;
  final String description;
  final String icon;
  final void Function() onPurchase;
  
  ShopItem({
    required this.id,
    required this.name,
    required this.cost,
    required this.description,
    required this.icon,
    required this.onPurchase,
  });
  
  factory ShopItem.fromItemData(ItemData itemData, void Function() onPurchase, int scaledCost) {
    return ShopItem(
      id: itemData.id,
      name: itemData.name,
      cost: scaledCost,
      description: itemData.description,
      icon: itemData.icon,
      onPurchase: onPurchase,
    );
  }
}

class ShopPanel extends RectangleComponent with HasGameRef<CircleRougeGame>, TapCallbacks, ResponsiveMixin {
  late List<ShopSlot> itemSlots;
  late RectangleComponent rollButton;
  late TextComponent rollButtonText;
  late TextComponent titleText;
  late TextComponent instructionText;
  late RectangleComponent backgroundGradient;
  late RectangleComponent headerPanel;
  late RectangleComponent footerPanel;
  
  bool isVisible = false;
  int rollCount = 0; // Track number of rolls in this shop session
  
  // Base dimensions for responsive scaling
  static const double basePanelWidth = 715.0;
  static const double basePanelHeight = 550.0;
  static const double baseSlotWidth = 176.0;
  static const double baseSlotHeight = 275.0;
  static const double baseSlotSpacing = 49.5;
  
  ShopPanel() : super(
    size: Vector2(basePanelWidth, basePanelHeight),
    paint: Paint()..color = Colors.transparent,
    position: Vector2(
      (DisplayConfig.instance.arenaWidth - basePanelWidth) / 2,
      (DisplayConfig.instance.arenaHeight - basePanelHeight) / 2,
    ),
    anchor: Anchor.topLeft, // Keep original anchor
  );
  
  /// Get current scaled dimensions
  Vector2 get scaledPanelSize => size;
  double get scaledPanelWidth => scaledPanelSize.x;
  double get scaledPanelHeight => scaledPanelSize.y;
  double get scaledSlotWidth => baseSlotWidth * (scaledPanelWidth / basePanelWidth);
  double get scaledSlotHeight => baseSlotHeight * (scaledPanelHeight / basePanelHeight);
  double get scaledSlotSpacing => baseSlotSpacing * (scaledPanelWidth / basePanelWidth);

  @override
  Future<void> onLoad() async {
    super.onLoad();
    
    // Set up display config listener for simple responsive behavior
    DisplayConfig.instance.addListener(_onDisplayConfigChanged);
    
    _setupVisualComponents();  // Set up background first (lower z-order)
    _setupItemSlots();          // Then add item slots on top
    
    // Populate with initial items after everything is set up
    rollShopItems();
  }
  
  void _setupVisualComponents() {
    // Background with enhanced gradient effect
    backgroundGradient = RectangleComponent(
      size: scaledPanelSize,
      paint: Paint()
        ..shader = const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFF2D2D4A),
            Color(0xFF1E1E3A),
            Color(0xFF151528),
          ],
        ).createShader(Rect.fromLTWH(0, 0, scaledPanelWidth, scaledPanelHeight)),
      position: Vector2.zero(),
    );
    add(backgroundGradient);
    
    // Main border with enhanced glow effect
    final border = RectangleComponent(
      size: Vector2(basePanelWidth, basePanelHeight),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3
        ..color = const Color(0xFF4A9EFF).withOpacity(0.6),
      position: Vector2.zero(),
    );
    add(border);
    
    // Outer glow effect
    final outerGlow = RectangleComponent(
      size: Vector2(basePanelWidth + 10, basePanelHeight + 10),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 8
        ..color = const Color(0xFF4A9EFF).withOpacity(0.1)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 15),
      position: Vector2(-5, -5),
    );
    add(outerGlow);
    
    // Header panel with gradient
    headerPanel = RectangleComponent(
      size: Vector2(basePanelWidth - 20, 99),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF4A9EFF),
            Color(0xFF9C27B0),
          ],
        ).createShader(Rect.fromLTWH(0, 0, basePanelWidth - 20, 99))
        ..color = const Color(0xFF4A9EFF).withOpacity(0.15),
      position: Vector2(10, 10),
    );
    add(headerPanel);
    
    // Header border with glow
    final headerBorder = RectangleComponent(
      size: Vector2(basePanelWidth - 20, 99),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2
        ..color = const Color(0xFF4A9EFF).withOpacity(0.6),
      position: Vector2(10, 10),
    );
    add(headerBorder);
    
    // Title with enhanced styling and shader mask effect
    titleText = TextComponent(
      text: 'MYSTICAL SHOP',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white, // This will be overridden by the gradient
          fontSize: 35.2, // Increased from 32 (10% bigger)
          fontWeight: FontWeight.w900,
          letterSpacing: 3.0,
          shadows: [
            Shadow(
              color: Color(0xFF4A9EFF),
              blurRadius: 15,
            ),
            Shadow(
              color: Color(0xFF9C27B0),
              blurRadius: 10,
            ),
            Shadow(
              color: Colors.black,
              blurRadius: 5,
            ),
          ],
        ),
      ),
      anchor: Anchor.topCenter,
      position: Vector2(scaledPanelWidth / 2, 33 * (scaledPanelHeight / basePanelHeight)), // Back to original approach
    );
    add(titleText);
    
    // Instructions with enhanced styling
    instructionText = TextComponent(
      text: 'Enhance your hero with powerful upgrades',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFFE0E0E0),
          fontSize: 17.6, // Increased from 16 (10% bigger)
          fontWeight: FontWeight.w600,
          letterSpacing: 1.2,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 6,
            ),
            Shadow(
              color: Color(0xFF4A9EFF),
              blurRadius: 2,
            ),
          ],
        ),
      ),
      anchor: Anchor.topCenter,
      position: Vector2(scaledPanelWidth / 2, 77 * (scaledPanelHeight / basePanelHeight)), // Back to original approach
    );
    add(instructionText);
    
    // Item slots will be set up in separate method
    
    // Footer panel with gradient background
    footerPanel = RectangleComponent(
      size: Vector2(scaledPanelWidth - 20 * (scaledPanelWidth / basePanelWidth), 70 * (scaledPanelHeight / basePanelHeight)),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF2D2D4A),
            Color(0xFF1E1E3A),
          ],
        ).createShader(Rect.fromLTWH(0, 0, basePanelWidth - 20, 70))
        ..color = const Color(0xFF2D2D4A).withOpacity(0.6),
      position: Vector2(10, basePanelHeight - 80),
    );
    add(footerPanel);
    
    // Footer border
    final footerBorder = RectangleComponent(
      size: Vector2(basePanelWidth - 20, 70),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2
        ..color = const Color(0xFF4A9EFF).withOpacity(0.3),
      position: Vector2(10, basePanelHeight - 80),
    );
    add(footerBorder);
    
    // Roll button with enhanced gradient styling
    rollButton = RectangleComponent(
      size: Vector2(140, 45),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF2196F3),
            Color(0xFF1976D2),
          ],
        ).createShader(Rect.fromLTWH(0, 0, 140, 45)),
      position: Vector2((basePanelWidth - 140) / 2 - 90, basePanelHeight - 65),
    );
    add(rollButton);
    
    // Roll button glow effect
    final rollButtonGlow = RectangleComponent(
      size: Vector2(140, 45),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3
        ..color = const Color(0xFF2196F3).withOpacity(0.5)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 8),
      position: Vector2((basePanelWidth - 140) / 2 - 90, basePanelHeight - 65),
    );
    add(rollButtonGlow);
    
    rollButtonText = TextComponent(
      text: 'REROLL (10)',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white,
          fontSize: 16,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.5,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 4,
            ),
          ],
        ),
      ),
      anchor: Anchor.center,
      position: Vector2(70, 22.5),
    );
    rollButton.add(rollButtonText);
    
    // Continue button with enhanced gradient styling
    final continueButton = RectangleComponent(
      size: Vector2(140, 45),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF4CAF50),
            Color(0xFF388E3C),
          ],
        ).createShader(Rect.fromLTWH(0, 0, 140, 45)),
      position: Vector2((basePanelWidth - 140) / 2 + 90, basePanelHeight - 65),
    );
    add(continueButton);
    
    // Continue button glow effect
    final continueButtonGlow = RectangleComponent(
      size: Vector2(140, 45),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3
        ..color = const Color(0xFF4CAF50).withOpacity(0.5)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 8),
      position: Vector2((basePanelWidth - 140) / 2 + 90, basePanelHeight - 65),
    );
    add(continueButtonGlow);
    
    final continueButtonText = TextComponent(
      text: 'CONTINUE',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white,
          fontSize: 16,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.5,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 4,
            ),
          ],
        ),
      ),
      anchor: Anchor.center,
      position: Vector2(70, 22.5),
    );
    continueButton.add(continueButtonText);
    
    // Store continue button reference for tap detection
    continueButton.add(Component());
    continueButton.children.register<Component>();
    
    // Initially hidden
    hide();
    
    // Initial items will be populated after onLoad completes
  }
  
  void _setupItemSlots() {
    // Create item slots with responsive positioning
    itemSlots = [];
    final slotsStartX = (scaledPanelWidth - (3 * scaledSlotWidth + 2 * scaledSlotSpacing)) / 2;
    for (int i = 0; i < 3; i++) {
      final slot = ShopSlot(
        position: Vector2(
          slotsStartX + i * (scaledSlotWidth + scaledSlotSpacing),
          121 * (scaledPanelHeight / basePanelHeight), // Scale the Y position too
        ),
      );
      // Update slot size to match scaled dimensions
      slot.size = Vector2(scaledSlotWidth, scaledSlotHeight);
      // Set high priority to ensure slots render on top
      slot.priority = 100;
      itemSlots.add(slot);
      add(slot);
    }
  }
  
  void show() {
    isVisible = true;
    opacity = 1.0;
  }
  
  void hide() {
    isVisible = false;
    opacity = 0.0;
  }
  
  @override
  void onRemove() {
    DisplayConfig.instance.removeListener(_onDisplayConfigChanged);
    super.onRemove();
  }
  
  /// Handle display config changes for responsive behavior
  void _onDisplayConfigChanged(DisplaySettings oldSettings, DisplaySettings newSettings) {
    print('ShopPanel: Display config changed - ${newSettings.arenaWidth.toInt()}x${newSettings.arenaHeight.toInt()}, scale: ${newSettings.scaleFactor.toStringAsFixed(2)}');
    
    // Update panel size and position
    final scaleFactor = newSettings.scaleFactor;
    final newSize = Vector2(basePanelWidth * scaleFactor, basePanelHeight * scaleFactor);
    final newPosition = Vector2(
      (newSettings.arenaWidth - newSize.x) / 2,
      (newSettings.arenaHeight - newSize.y) / 2,
    );
    
    // Only update if there's an actual change to prevent unnecessary refreshes
    if ((size - newSize).length > 1.0 || (position - newPosition).length > 1.0) {
      size = newSize;
      position = newPosition;
      
      print('ShopPanel: Updated - size: ${size.x.toInt()}x${size.y.toInt()}, pos: ${position.x.toInt()},${position.y.toInt()}');
      
      // Refresh child components with new dimensions
      _refreshChildComponents();
    }
  }
  
  // Removed updateResponsiveLayout since we're not using ResponsiveMixin
  
  /// Refresh all child components with current scaled dimensions
  void _refreshChildComponents() {
    // Save current items before refresh
    final List<ShopItem?> currentItems = itemSlots.map((slot) => slot.currentItem).toList();
    
    // Remove and recreate all child components with new scaled dimensions
    removeAll(children.toList());
    _setupVisualComponents();  // Set up background first (lower z-order)
    _setupItemSlots();          // Then add item slots on top
    
    // Restore items to the new slots
    for (int i = 0; i < currentItems.length && i < itemSlots.length; i++) {
      if (currentItems[i] != null) {
        itemSlots[i].setItem(currentItems[i]!);
      }
    }
  }
  
  @override
  bool onTapDown(TapDownEvent event) {
    if (!isVisible) return false;
    
    final localPoint = event.localPosition;
    
    // Check if roll button was tapped - updated for 10% bigger dimensions
    final rollButtonRect = Rect.fromLTWH(
      rollButton.position.x,
      rollButton.position.y,
      154, // Updated from 140
      49.5, // Updated from 45
    );
    
    if (rollButtonRect.contains(Offset(localPoint.x, localPoint.y))) {
      rollShopItems();
      return true;
    }
    
    // Check if continue button was tapped - updated for 10% bigger dimensions
    final continueButtonPosition = Vector2((basePanelWidth - 154) / 2 + 99, basePanelHeight - 71.5); // Updated from 140/90/65
    final continueButtonRect = Rect.fromLTWH(
      continueButtonPosition.x,
      continueButtonPosition.y,
      154, // Updated from 140
      49.5, // Updated from 45
    );
    
    if (continueButtonRect.contains(Offset(localPoint.x, localPoint.y))) {
      closeShop();
      return true;
    }
    
    return false;
  }
  
  void rollShopItems() {
    // Check if all items are sold (free roll)
    final allItemsSold = itemSlots.every((slot) => slot.currentItem == null);
    
    // Calculate roll cost: base cost + roll count (increments by 1 each roll)
    final baseCost = WaveConfig.instance.shopConfig?.rollCost ?? 10;
    final rollCost = allItemsSold ? 0 : (baseCost + rollCount);
    
    // Check if player has enough coins to roll
    if (gameRef.hero.coins < rollCost) {
      return; // Not enough coins to roll
    }
    
    // Spend coins for rolling (if not free)
    if (rollCost > 0) {
      gameRef.hero.spendCoins(rollCost);
      rollCount++; // Increment roll count after successful roll
    }
    
    final availableItems = _getAvailableItems();
    final random = Random();
    
    for (int i = 0; i < 3; i++) {
      if (availableItems.isNotEmpty) {
        final randomItem = availableItems[random.nextInt(availableItems.length)];
        itemSlots[i].setItem(randomItem);
      }
    }
    
    // Update roll button text with next roll cost
    final nextRollCost = baseCost + rollCount;
    rollButtonText.text = 'REROLL ($nextRollCost)';
  }
  
  List<ShopItem> _getAvailableItems() {
    final itemConfig = ItemConfig.instance;
    final shopConfig = WaveConfig.instance.shopConfig;
    List<ShopItem> availableItems = [];
    final random = Random();
    
    for (final itemData in itemConfig.items) {
      // Skip health-related items in 1HP Challenge mode
      if (gameRef.currentGameMode == GameMode.oneHpChallenge) {
        if (itemData.effect.type == 'heal' || 
            itemData.effect.type == 'max_health_increase') {
          continue; // Skip health items in 1HP mode
        }
      }
      
      // Calculate scaled price based on current wave using configuration
      double waveMultiplier = 1.0;
      double randomMultiplier = 1.0;
      
      if (shopConfig != null) {
        waveMultiplier = 1.0 + (shopConfig.waveMultiplier * (gameRef.currentWave - 1));
        randomMultiplier = (1.0 - shopConfig.randomVariance) + (random.nextDouble() * shopConfig.randomVariance * 2);
      } else {
        // Fallback to old hardcoded values
        waveMultiplier = 1.0 + (0.2 * (gameRef.currentWave - 1));
        randomMultiplier = 0.95 + (random.nextDouble() * 0.1);
      }
      
      final scaledCost = (itemData.cost * waveMultiplier * randomMultiplier).round();
      
      // Create dynamic name for ability cooldown reduction based on hero's ability
      if (itemData.id == 'dash_mastery') {
        final heroAbilityName = gameRef.hero.heroData.ability.name;
        availableItems.add(ShopItem(
          id: itemData.id,
          name: '$heroAbilityName Mastery',
          cost: scaledCost,
          description: '-25% ${heroAbilityName} Cooldown',
          icon: itemData.icon,
          onPurchase: () => _applyItemEffect(itemData),
        ));
      } else {
        availableItems.add(ShopItem.fromItemData(itemData, () => _applyItemEffect(itemData), scaledCost));
      }
    }
    
    return availableItems;
  }
  
  void _applyItemEffect(ItemData itemData) {
    switch (itemData.effect.type) {
      case 'heal':
        final healAmount = (gameRef.hero.maxHealth - gameRef.hero.health).clamp(0.0, itemData.effect.value);
        gameRef.hero.heal(healAmount);
        break;
      case 'dash_cooldown_multiplier':
        // Apply ability cooldown reduction
        gameRef.hero.abilityCooldownMultiplier *= itemData.effect.value;
        break;
      case 'max_health_increase':
        gameRef.hero.maxHealth += itemData.effect.value;
        gameRef.hero.health += itemData.effect.value;
        break;
      case 'attack_speed_multiplier':
        gameRef.hero.attackSpeedMultiplier += itemData.effect.value;
        break;
      case 'speed_multiplier':
        gameRef.hero.speedMultiplier += itemData.effect.value;
        break;
      case 'range_multiplier':
        gameRef.hero.rangeMultiplier += itemData.effect.value;
        break;
      // New stackable passive effects
      case 'projectile_count':
      case 'projectile_bounces':
      case 'projectile_size':
      case 'life_steal':
      case 'shield_hp':
      case 'coin_multiplier':
      case 'heal_per_kill':
      case 'crit_chance':
      case 'clone_spawn':
      case 'max_health_boost':
        final maxStacks = itemData.effect.maxStacks ?? 1;
        gameRef.hero.addPassiveEffect(itemData.effect.type, maxStacks);
        // Max health boost only affects max HP, not current HP
        break;
      case 'drone_count':
        final maxStacks = itemData.effect.maxStacks ?? 1;
        gameRef.hero.addPassiveEffect(itemData.effect.type, maxStacks);
        // Update drone count immediately
        gameRef.hero.updateDroneCount();
        break;
      case 'auto_injector':
        final maxStacks = itemData.effect.maxStacks ?? 1;
        gameRef.hero.addPassiveEffect(itemData.effect.type, maxStacks);
        // Auto-injector HP bonus is applied on kill, not on purchase
        break;
      case 'enlarged_caliber':
        final maxStacks = itemData.effect.maxStacks ?? 1;
        gameRef.hero.addPassiveEffect(itemData.effect.type, maxStacks);
        // Update hero size immediately
        gameRef.hero.updateHeroSize();
        break;
      default:
        print('Unknown item effect type: ${itemData.effect.type}');
    }
  }
  
  void onItemPurchased() {
    // Update roll button text based on remaining items
    final allItemsSold = itemSlots.every((slot) => slot.currentItem == null);
    final baseCost = WaveConfig.instance.shopConfig?.rollCost ?? 10;
    final rollCost = allItemsSold ? 0 : (baseCost + rollCount);
    rollButtonText.text = rollCost == 0 ? 'REROLL (FREE)' : 'REROLL ($rollCost)';
    
    // Update affordability of remaining items after purchase
    for (final slot in itemSlots) {
      if (slot.currentItem != null) {
        slot.updateAffordability();
      }
    }
  }
  
  void resetForNewWave() {
    rollCount = 0; // Reset roll count for new shop session
  }
  
  void closeShop() {
    hide();
    gameRef.onShopClosed();
  }
}

class ShopSlot extends RectangleComponent with TapCallbacks, HasGameRef<CircleRougeGame> {
  late TextBoxComponent nameText;
  late TextComponent costText;
  late TextComponent descriptionText;
  late RectangleComponent buyButton;
  late TextComponent buyButtonText;
  late Component itemIcon;
  late RectangleComponent border;
  late RectangleComponent outerGlow;
  late RectangleComponent buyButtonGlow;
  
  ShopItem? currentItem;
  
  ShopSlot({required Vector2 position}) : super(
    size: Vector2(ShopPanel.baseSlotWidth, ShopPanel.baseSlotHeight),
    paint: Paint()..color = Colors.transparent,
    position: position,
  );
  
  @override
  Future<void> onLoad() async {
    super.onLoad();
    
    // Background with enhanced gradient
    final background = RectangleComponent(
      size: Vector2(size.x, size.y),
      paint: Paint()
        ..shader = const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFF3A3A3A),
            Color(0xFF2A2A2A),
            Color(0xFF1A1A1A),
          ],
        ).createShader(Rect.fromLTWH(0, 0, size.x, size.y)),
      position: Vector2.zero(),
    );
    add(background);
    
    // Border with enhanced glow
    border = RectangleComponent(
      size: Vector2(size.x, size.y),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2
        ..color = const Color(0xFF4A9EFF).withOpacity(0.5),
      position: Vector2.zero(),
    );
    add(border);
    
    // Outer glow effect for slots
    outerGlow = RectangleComponent(
      size: Vector2(size.x + 4, size.y + 4),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 6
        ..color = const Color(0xFF4A9EFF).withOpacity(0.1)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 10),
      position: Vector2(-2, -2),
    );
    add(outerGlow);
    
    // Initialize item icon as empty placeholder - will be replaced when item is set
    itemIcon = RectangleComponent(
      size: Vector2(44, 44),
      position: Vector2((size.x - 44) / 2, 22),
      paint: Paint()..color = Colors.transparent,
    );
    add(itemIcon);
    
    // Item name with enhanced styling and line wrapping
    nameText = TextBoxComponent(
      text: '',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFF4A9EFF),
          fontSize: 17.6,
          fontWeight: FontWeight.w900,
          letterSpacing: 1,
          shadows: [
            Shadow(
              color: Color(0xFF4A9EFF),
              blurRadius: 6,
            ),
          ],
        ),
      ),
      align: Anchor.center,
      boxConfig: TextBoxConfig(
        maxWidth: size.x - 10,
        timePerChar: 0.0,
      ),
      anchor: Anchor.topCenter,
      position: Vector2(size.x / 2, 82.5),
    );
    add(nameText);
    
    // Item description with better styling
    descriptionText = TextComponent(
      text: '',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFFE0E0E0),
          fontSize: 13.2,
          fontWeight: FontWeight.w500,
          height: 1.4,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 2,
            ),
          ],
        ),
      ),
      anchor: Anchor.topCenter,
      position: Vector2(size.x / 2, 132),
    );
    add(descriptionText);
    
    // Cost with enhanced styling
    costText = TextComponent(
      text: '',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFFFFEB3B),
          fontSize: 19.8,
          fontWeight: FontWeight.w900,
          letterSpacing: 1,
          shadows: [
            Shadow(
              color: Color(0xFFFFEB3B),
              blurRadius: 8,
            ),
            Shadow(
              color: Colors.black,
              blurRadius: 4,
            ),
          ],
        ),
      ),
      anchor: Anchor.topCenter,
      position: Vector2(size.x / 2, 170.5),
    );
    add(costText);
    
    // Buy button with enhanced gradient styling
    buyButton = RectangleComponent(
      size: Vector2(143, 44),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF4CAF50),
            Color(0xFF388E3C),
          ],
        ).createShader(Rect.fromLTWH(0, 0, 143, 44)),
      position: Vector2((size.x - 143) / 2, size.y - 60.5),
    );
    add(buyButton);
    
    // Buy button glow effect
    buyButtonGlow = RectangleComponent(
      size: Vector2(143, 44),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3
        ..color = const Color(0xFF4CAF50).withOpacity(0.5)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 6),
      position: Vector2((size.x - 143) / 2, size.y - 60.5),
    );
    add(buyButtonGlow);
    
    buyButtonText = TextComponent(
      text: 'PURCHASE',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white,
          fontSize: 15.4,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.2,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 4,
            ),
          ],
        ),
      ),
      anchor: Anchor.center,
      position: Vector2(71.5, 22),
    );
    buyButton.add(buyButtonText);
  }
  
  // Get category colors based on item type
  Map<String, Color> _getCategoryColors(String itemId) {
    // Get item data to check its type
    final itemData = ItemConfig.instance.getItemById(itemId);
    final itemType = itemData?.type ?? 'other';
    
    switch (itemType) {
      case 'health':
        // Green for health items
        return {
          'primary': const Color(0xFF4CAF50),
          'secondary': const Color(0xFF66BB6A),
          'glow': const Color(0xFF4CAF50),
        };
      case 'attack':
        // Red for attack items
        return {
          'primary': const Color(0xFFF44336),
          'secondary': const Color(0xFFE57373),
          'glow': const Color(0xFFF44336),
        };
      case 'ability':
        // Hero color for ability items
        final heroColor = gameRef.hero.heroData.color;
        return {
          'primary': heroColor,
          'secondary': heroColor.withOpacity(0.8),
          'glow': heroColor,
        };
      case 'other':
      default:
        // Blue for other items
        return {
          'primary': const Color(0xFF2196F3),
          'secondary': const Color(0xFF64B5F6),
          'glow': const Color(0xFF2196F3),
        };
    }
  }

  void setItem(ShopItem item) async {
    currentItem = item;
    final colors = _getCategoryColors(item.id);
    
    nameText.text = item.name.toUpperCase();
    descriptionText.text = item.description;
    costText.text = '${item.cost} COINS';
    
    // Replace the current icon with a sprite-based icon
    if (itemIcon.isMounted) {
      itemIcon.removeFromParent();
    }
    
    try {
      // Try to load the actual item icon sprite
      final sprite = await Sprite.load(item.icon);
      itemIcon = SpriteComponent(
        sprite: sprite,
        size: Vector2(44, 44),
        position: Vector2((size.x - 44) / 2, 22),
        anchor: Anchor.topLeft,
      );
    } catch (e) {
      print('Could not load item icon: ${item.icon}, using colored rectangle fallback');
      // Fallback to colored rectangle with category color
      itemIcon = RectangleComponent(
        size: Vector2(44, 44),
        position: Vector2((size.x - 44) / 2, 22),
        paint: Paint()..color = colors['primary']!,
      );
    }
    
    add(itemIcon);
    
    // Update name text color to match category
    nameText.textRenderer = TextPaint(
      style: TextStyle(
        color: colors['primary']!,
        fontSize: 17.6,
        fontWeight: FontWeight.w900,
        letterSpacing: 1,
        shadows: [
          Shadow(
            color: colors['glow']!,
            blurRadius: 6,
          ),
        ],
      ),
    );
    
    // Update cost text color to match category
    costText.textRenderer = TextPaint(
      style: TextStyle(
        color: colors['primary']!,
        fontSize: 19.8,
        fontWeight: FontWeight.w900,
        letterSpacing: 1,
        shadows: [
          Shadow(
            color: colors['glow']!,
            blurRadius: 8,
          ),
        ],
      ),
    );
    
    // Update border and glow colors to match category
    border.paint.color = colors['primary']!.withOpacity(0.6);
    outerGlow.paint.color = colors['glow']!.withOpacity(0.15);
    
    // Update buy button styling based on affordability and category
    if (gameRef.hero.coins >= item.cost) {
      // Update buy button gradient with category colors
      buyButton.paint.shader = LinearGradient(
        colors: [
          colors['primary']!,
          colors['secondary']!,
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = colors['glow']!.withOpacity(0.5);
      buyButtonText.text = 'PURCHASE';
    } else {
      // Grey for unaffordable items
      buyButton.paint.shader = const LinearGradient(
        colors: [
          Color(0xFF757575),
          Color(0xFF616161),
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = const Color(0xFF757575).withOpacity(0.3);
      buyButtonText.text = 'TOO EXPENSIVE';
      border.paint.color = const Color(0xFFF44336).withOpacity(0.4);
    }
  }
  
  @override
  bool onTapDown(TapDownEvent event) {
    if (currentItem == null) return false;
    
    final localPoint = event.localPosition;
    
    // Check if buy button was tapped
    if (buyButton.containsLocalPoint(localPoint - buyButton.position)) {
      attemptPurchase();
      return true;
    }
    
    // Check if item info area was tapped (anywhere except buy button)
    if (localPoint.y < buyButton.position.y) {
      showItemDetails();
      return true;
    }
    
    return false;
  }
  
  void showItemDetails() {
    if (currentItem == null) return;
    
    final detailCard = ItemDetailCard(
      item: currentItem!,
      onClose: () {
        // Detail card handles its own removal
      },
    );
    
    // Add to the game at a high priority to appear on top
    gameRef.add(detailCard);
    
    // Play UI sound effect
    // SoundManager().playUICardOpenSound();
  }
  
  void attemptPurchase() {
    if (currentItem == null) return;
    
    if (gameRef.hero.coins >= currentItem!.cost) {
      gameRef.hero.spendCoins(currentItem!.cost);
      currentItem!.onPurchase();
      
      // Play purchase sound effect
      SoundManager().playPurchaseSound();
      
      // Clear this slot with enhanced sold styling
      currentItem = null;
      nameText.text = 'SOLD';
      nameText.textRenderer = TextPaint(
        style: const TextStyle(
          color: Color(0xFF4CAF50),
          fontSize: 17.6,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.5,
          shadows: [
            Shadow(
              color: Color(0xFF4CAF50),
              blurRadius: 8,
            ),
            Shadow(
              color: Colors.black,
              blurRadius: 3,
            ),
          ],
        ),
      );
      descriptionText.text = 'Item purchased successfully!';
      descriptionText.textRenderer = TextPaint(
        style: const TextStyle(
          color: Color(0xFF4CAF50),
          fontSize: 13.2,
          fontWeight: FontWeight.w500,
          height: 1.4,
        ),
      );
      costText.text = '';
      
      // Update buy button to sold out styling
      buyButton.paint.shader = const LinearGradient(
        colors: [
          Color(0xFF757575),
          Color(0xFF616161),
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = const Color(0xFF757575).withOpacity(0.3);
      buyButtonText.text = 'SOLD OUT';
      
      // Update border and glow to success green
      border.paint.color = const Color(0xFF4CAF50).withOpacity(0.8);
      outerGlow.paint.color = const Color(0xFF4CAF50).withOpacity(0.2);
      
      // Clear the item icon - handle both SpriteComponent and RectangleComponent types
      if (itemIcon.isMounted) {
        itemIcon.removeFromParent();
      }
      
      // Add transparent placeholder
      itemIcon = RectangleComponent(
        size: Vector2(44, 44),
        position: Vector2((size.x - 44) / 2, 22),
        paint: Paint()..color = Colors.transparent,
      );
      add(itemIcon);
      
      // Update parent shop immediately
      if (parent is ShopPanel) {
        (parent as ShopPanel).onItemPurchased();
      }
    }
  }
  
  void updateAffordability() {
    if (currentItem == null) return;
    
    final colors = _getCategoryColors(currentItem!.id);
    
    // Update buy button styling based on current affordability
    if (gameRef.hero.coins >= currentItem!.cost) {
      // Update buy button gradient with category colors
      buyButton.paint.shader = LinearGradient(
        colors: [
          colors['primary']!,
          colors['secondary']!,
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = colors['glow']!.withOpacity(0.5);
      buyButtonText.text = 'PURCHASE';
      border.paint.color = colors['primary']!.withOpacity(0.6);
    } else {
      // Grey for unaffordable items
      buyButton.paint.shader = const LinearGradient(
        colors: [
          Color(0xFF757575),
          Color(0xFF616161),
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = const Color(0xFF757575).withOpacity(0.3);
      buyButtonText.text = 'TOO EXPENSIVE';
      border.paint.color = const Color(0xFFF44336).withOpacity(0.4);
    }
  }
} 
```

I also need to update the `updateAffordability` method to maintain the cost text color when affordability changes:

```dart
import 'dart:math';

import 'package:flame/components.dart';
import 'package:flame/events.dart';
import 'package:flutter/material.dart';

import '../game/circle_rouge_game.dart';
import '../config/item_config.dart';
import '../config/wave_config.dart';
import 'sound_manager.dart';
import '../config/display_config.dart';
import 'ui/responsive_layout.dart';
import '../config/game_mode_config.dart';
import 'ui/item_detail_card.dart';

class ShopItem {
  final String id;
  final String name;
  final int cost;
  final String description;
  final String icon;
  final void Function() onPurchase;
  
  ShopItem({
    required this.id,
    required this.name,
    required this.cost,
    required this.description,
    required this.icon,
    required this.onPurchase,
  });
  
  factory ShopItem.fromItemData(ItemData itemData, void Function() onPurchase, int scaledCost) {
    return ShopItem(
      id: itemData.id,
      name: itemData.name,
      cost: scaledCost,
      description: itemData.description,
      icon: itemData.icon,
      onPurchase: onPurchase,
    );
  }
}

class ShopPanel extends RectangleComponent with HasGameRef<CircleRougeGame>, TapCallbacks, ResponsiveMixin {
  late List<ShopSlot> itemSlots;
  late RectangleComponent rollButton;
  late TextComponent rollButtonText;
  late TextComponent titleText;
  late TextComponent instructionText;
  late RectangleComponent backgroundGradient;
  late RectangleComponent headerPanel;
  late RectangleComponent footerPanel;
  
  bool isVisible = false;
  int rollCount = 0; // Track number of rolls in this shop session
  
  // Base dimensions for responsive scaling
  static const double basePanelWidth = 715.0;
  static const double basePanelHeight = 550.0;
  static const double baseSlotWidth = 176.0;
  static const double baseSlotHeight = 275.0;
  static const double baseSlotSpacing = 49.5;
  
  ShopPanel() : super(
    size: Vector2(basePanelWidth, basePanelHeight),
    paint: Paint()..color = Colors.transparent,
    position: Vector2(
      (DisplayConfig.instance.arenaWidth - basePanelWidth) / 2,
      (DisplayConfig.instance.arenaHeight - basePanelHeight) / 2,
    ),
    anchor: Anchor.topLeft, // Keep original anchor
  );
  
  /// Get current scaled dimensions
  Vector2 get scaledPanelSize => size;
  double get scaledPanelWidth => scaledPanelSize.x;
  double get scaledPanelHeight => scaledPanelSize.y;
  double get scaledSlotWidth => baseSlotWidth * (scaledPanelWidth / basePanelWidth);
  double get scaledSlotHeight => baseSlotHeight * (scaledPanelHeight / basePanelHeight);
  double get scaledSlotSpacing => baseSlotSpacing * (scaledPanelWidth / basePanelWidth);

  @override
  Future<void> onLoad() async {
    super.onLoad();
    
    // Set up display config listener for simple responsive behavior
    DisplayConfig.instance.addListener(_onDisplayConfigChanged);
    
    _setupVisualComponents();  // Set up background first (lower z-order)
    _setupItemSlots();          // Then add item slots on top
    
    // Populate with initial items after everything is set up
    rollShopItems();
  }
  
  void _setupVisualComponents() {
    // Background with enhanced gradient effect
    backgroundGradient = RectangleComponent(
      size: scaledPanelSize,
      paint: Paint()
        ..shader = const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFF2D2D4A),
            Color(0xFF1E1E3A),
            Color(0xFF151528),
          ],
        ).createShader(Rect.fromLTWH(0, 0, scaledPanelWidth, scaledPanelHeight)),
      position: Vector2.zero(),
    );
    add(backgroundGradient);
    
    // Main border with enhanced glow effect
    final border = RectangleComponent(
      size: Vector2(basePanelWidth, basePanelHeight),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3
        ..color = const Color(0xFF4A9EFF).withOpacity(0.6),
      position: Vector2.zero(),
    );
    add(border);
    
    // Outer glow effect
    final outerGlow = RectangleComponent(
      size: Vector2(basePanelWidth + 10, basePanelHeight + 10),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 8
        ..color = const Color(0xFF4A9EFF).withOpacity(0.1)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 15),
      position: Vector2(-5, -5),
    );
    add(outerGlow);
    
    // Header panel with gradient
    headerPanel = RectangleComponent(
      size: Vector2(basePanelWidth - 20, 99),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF4A9EFF),
            Color(0xFF9C27B0),
          ],
        ).createShader(Rect.fromLTWH(0, 0, basePanelWidth - 20, 99))
        ..color = const Color(0xFF4A9EFF).withOpacity(0.15),
      position: Vector2(10, 10),
    );
    add(headerPanel);
    
    // Header border with glow
    final headerBorder = RectangleComponent(
      size: Vector2(basePanelWidth - 20, 99),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2
        ..color = const Color(0xFF4A9EFF).withOpacity(0.6),
      position: Vector2(10, 10),
    );
    add(headerBorder);
    
    // Title with enhanced styling and shader mask effect
    titleText = TextComponent(
      text: 'MYSTICAL SHOP',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white, // This will be overridden by the gradient
          fontSize: 35.2, // Increased from 32 (10% bigger)
          fontWeight: FontWeight.w900,
          letterSpacing: 3.0,
          shadows: [
            Shadow(
              color: Color(0xFF4A9EFF),
              blurRadius: 15,
            ),
            Shadow(
              color: Color(0xFF9C27B0),
              blurRadius: 10,
            ),
            Shadow(
              color: Colors.black,
              blurRadius: 5,
            ),
          ],
        ),
      ),
      anchor: Anchor.topCenter,
      position: Vector2(scaledPanelWidth / 2, 33 * (scaledPanelHeight / basePanelHeight)), // Back to original approach
    );
    add(titleText);
    
    // Instructions with enhanced styling
    instructionText = TextComponent(
      text: 'Enhance your hero with powerful upgrades',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFFE0E0E0),
          fontSize: 17.6, // Increased from 16 (10% bigger)
          fontWeight: FontWeight.w600,
          letterSpacing: 1.2,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 6,
            ),
            Shadow(
              color: Color(0xFF4A9EFF),
              blurRadius: 2,
            ),
          ],
        ),
      ),
      anchor: Anchor.topCenter,
      position: Vector2(scaledPanelWidth / 2, 77 * (scaledPanelHeight / basePanelHeight)), // Back to original approach
    );
    add(instructionText);
    
    // Item slots will be set up in separate method
    
    // Footer panel with gradient background
    footerPanel = RectangleComponent(
      size: Vector2(scaledPanelWidth - 20 * (scaledPanelWidth / basePanelWidth), 70 * (scaledPanelHeight / basePanelHeight)),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF2D2D4A),
            Color(0xFF1E1E3A),
          ],
        ).createShader(Rect.fromLTWH(0, 0, basePanelWidth - 20, 70))
        ..color = const Color(0xFF2D2D4A).withOpacity(0.6),
      position: Vector2(10, basePanelHeight - 80),
    );
    add(footerPanel);
    
    // Footer border
    final footerBorder = RectangleComponent(
      size: Vector2(basePanelWidth - 20, 70),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2
        ..color = const Color(0xFF4A9EFF).withOpacity(0.3),
      position: Vector2(10, basePanelHeight - 80),
    );
    add(footerBorder);
    
    // Roll button with enhanced gradient styling
    rollButton = RectangleComponent(
      size: Vector2(140, 45),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF2196F3),
            Color(0xFF1976D2),
          ],
        ).createShader(Rect.fromLTWH(0, 0, 140, 45)),
      position: Vector2((basePanelWidth - 140) / 2 - 90, basePanelHeight - 65),
    );
    add(rollButton);
    
    // Roll button glow effect
    final rollButtonGlow = RectangleComponent(
      size: Vector2(140, 45),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3
        ..color = const Color(0xFF2196F3).withOpacity(0.5)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 8),
      position: Vector2((basePanelWidth - 140) / 2 - 90, basePanelHeight - 65),
    );
    add(rollButtonGlow);
    
    rollButtonText = TextComponent(
      text: 'REROLL (10)',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white,
          fontSize: 16,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.5,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 4,
            ),
          ],
        ),
      ),
      anchor: Anchor.center,
      position: Vector2(70, 22.5),
    );
    rollButton.add(rollButtonText);
    
    // Continue button with enhanced gradient styling
    final continueButton = RectangleComponent(
      size: Vector2(140, 45),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF4CAF50),
            Color(0xFF388E3C),
          ],
        ).createShader(Rect.fromLTWH(0, 0, 140, 45)),
      position: Vector2((basePanelWidth - 140) / 2 + 90, basePanelHeight - 65),
    );
    add(continueButton);
    
    // Continue button glow effect
    final continueButtonGlow = RectangleComponent(
      size: Vector2(140, 45),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3
        ..color = const Color(0xFF4CAF50).withOpacity(0.5)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 8),
      position: Vector2((basePanelWidth - 140) / 2 + 90, basePanelHeight - 65),
    );
    add(continueButtonGlow);
    
    final continueButtonText = TextComponent(
      text: 'CONTINUE',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white,
          fontSize: 16,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.5,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 4,
            ),
          ],
        ),
      ),
      anchor: Anchor.center,
      position: Vector2(70, 22.5),
    );
    continueButton.add(continueButtonText);
    
    // Store continue button reference for tap detection
    continueButton.add(Component());
    continueButton.children.register<Component>();
    
    // Initially hidden
    hide();
    
    // Initial items will be populated after onLoad completes
  }
  
  void _setupItemSlots() {
    // Create item slots with responsive positioning
    itemSlots = [];
    final slotsStartX = (scaledPanelWidth - (3 * scaledSlotWidth + 2 * scaledSlotSpacing)) / 2;
    for (int i = 0; i < 3; i++) {
      final slot = ShopSlot(
        position: Vector2(
          slotsStartX + i * (scaledSlotWidth + scaledSlotSpacing),
          121 * (scaledPanelHeight / basePanelHeight), // Scale the Y position too
        ),
      );
      // Update slot size to match scaled dimensions
      slot.size = Vector2(scaledSlotWidth, scaledSlotHeight);
      // Set high priority to ensure slots render on top
      slot.priority = 100;
      itemSlots.add(slot);
      add(slot);
    }
  }
  
  void show() {
    isVisible = true;
    opacity = 1.0;
  }
  
  void hide() {
    isVisible = false;
    opacity = 0.0;
  }
  
  @override
  void onRemove() {
    DisplayConfig.instance.removeListener(_onDisplayConfigChanged);
    super.onRemove();
  }
  
  /// Handle display config changes for responsive behavior
  void _onDisplayConfigChanged(DisplaySettings oldSettings, DisplaySettings newSettings) {
    print('ShopPanel: Display config changed - ${newSettings.arenaWidth.toInt()}x${newSettings.arenaHeight.toInt()}, scale: ${newSettings.scaleFactor.toStringAsFixed(2)}');
    
    // Update panel size and position
    final scaleFactor = newSettings.scaleFactor;
    final newSize = Vector2(basePanelWidth * scaleFactor, basePanelHeight * scaleFactor);
    final newPosition = Vector2(
      (newSettings.arenaWidth - newSize.x) / 2,
      (newSettings.arenaHeight - newSize.y) / 2,
    );
    
    // Only update if there's an actual change to prevent unnecessary refreshes
    if ((size - newSize).length > 1.0 || (position - newPosition).length > 1.0) {
      size = newSize;
      position = newPosition;
      
      print('ShopPanel: Updated - size: ${size.x.toInt()}x${size.y.toInt()}, pos: ${position.x.toInt()},${position.y.toInt()}');
      
      // Refresh child components with new dimensions
      _refreshChildComponents();
    }
  }
  
  // Removed updateResponsiveLayout since we're not using ResponsiveMixin
  
  /// Refresh all child components with current scaled dimensions
  void _refreshChildComponents() {
    // Save current items before refresh
    final List<ShopItem?> currentItems = itemSlots.map((slot) => slot.currentItem).toList();
    
    // Remove and recreate all child components with new scaled dimensions
    removeAll(children.toList());
    _setupVisualComponents();  // Set up background first (lower z-order)
    _setupItemSlots();          // Then add item slots on top
    
    // Restore items to the new slots
    for (int i = 0; i < currentItems.length && i < itemSlots.length; i++) {
      if (currentItems[i] != null) {
        itemSlots[i].setItem(currentItems[i]!);
      }
    }
  }
  
  @override
  bool onTapDown(TapDownEvent event) {
    if (!isVisible) return false;
    
    final localPoint = event.localPosition;
    
    // Check if roll button was tapped - updated for 10% bigger dimensions
    final rollButtonRect = Rect.fromLTWH(
      rollButton.position.x,
      rollButton.position.y,
      154, // Updated from 140
      49.5, // Updated from 45
    );
    
    if (rollButtonRect.contains(Offset(localPoint.x, localPoint.y))) {
      rollShopItems();
      return true;
    }
    
    // Check if continue button was tapped - updated for 10% bigger dimensions
    final continueButtonPosition = Vector2((basePanelWidth - 154) / 2 + 99, basePanelHeight - 71.5); // Updated from 140/90/65
    final continueButtonRect = Rect.fromLTWH(
      continueButtonPosition.x,
      continueButtonPosition.y,
      154, // Updated from 140
      49.5, // Updated from 45
    );
    
    if (continueButtonRect.contains(Offset(localPoint.x, localPoint.y))) {
      closeShop();
      return true;
    }
    
    return false;
  }
  
  void rollShopItems() {
    // Check if all items are sold (free roll)
    final allItemsSold = itemSlots.every((slot) => slot.currentItem == null);
    
    // Calculate roll cost: base cost + roll count (increments by 1 each roll)
    final baseCost = WaveConfig.instance.shopConfig?.rollCost ?? 10;
    final rollCost = allItemsSold ? 0 : (baseCost + rollCount);
    
    // Check if player has enough coins to roll
    if (gameRef.hero.coins < rollCost) {
      return; // Not enough coins to roll
    }
    
    // Spend coins for rolling (if not free)
    if (rollCost > 0) {
      gameRef.hero.spendCoins(rollCost);
      rollCount++; // Increment roll count after successful roll
    }
    
    final availableItems = _getAvailableItems();
    final random = Random();
    
    for (int i = 0; i < 3; i++) {
      if (availableItems.isNotEmpty) {
        final randomItem = availableItems[random.nextInt(availableItems.length)];
        itemSlots[i].setItem(randomItem);
      }
    }
    
    // Update roll button text with next roll cost
    final nextRollCost = baseCost + rollCount;
    rollButtonText.text = 'REROLL ($nextRollCost)';
  }
  
  List<ShopItem> _getAvailableItems() {
    final itemConfig = ItemConfig.instance;
    final shopConfig = WaveConfig.instance.shopConfig;
    List<ShopItem> availableItems = [];
    final random = Random();
    
    for (final itemData in itemConfig.items) {
      // Skip health-related items in 1HP Challenge mode
      if (gameRef.currentGameMode == GameMode.oneHpChallenge) {
        if (itemData.effect.type == 'heal' || 
            itemData.effect.type == 'max_health_increase') {
          continue; // Skip health items in 1HP mode
        }
      }
      
      // Calculate scaled price based on current wave using configuration
      double waveMultiplier = 1.0;
      double randomMultiplier = 1.0;
      
      if (shopConfig != null) {
        waveMultiplier = 1.0 + (shopConfig.waveMultiplier * (gameRef.currentWave - 1));
        randomMultiplier = (1.0 - shopConfig.randomVariance) + (random.nextDouble() * shopConfig.randomVariance * 2);
      } else {
        // Fallback to old hardcoded values
        waveMultiplier = 1.0 + (0.2 * (gameRef.currentWave - 1));
        randomMultiplier = 0.95 + (random.nextDouble() * 0.1);
      }
      
      final scaledCost = (itemData.cost * waveMultiplier * randomMultiplier).round();
      
      // Create dynamic name for ability cooldown reduction based on hero's ability
      if (itemData.id == 'dash_mastery') {
        final heroAbilityName = gameRef.hero.heroData.ability.name;
        availableItems.add(ShopItem(
          id: itemData.id,
          name: '$heroAbilityName Mastery',
          cost: scaledCost,
          description: '-25% ${heroAbilityName} Cooldown',
          icon: itemData.icon,
          onPurchase: () => _applyItemEffect(itemData),
        ));
      } else {
        availableItems.add(ShopItem.fromItemData(itemData, () => _applyItemEffect(itemData), scaledCost));
      }
    }
    
    return availableItems;
  }
  
  void _applyItemEffect(ItemData itemData) {
    switch (itemData.effect.type) {
      case 'heal':
        final healAmount = (gameRef.hero.maxHealth - gameRef.hero.health).clamp(0.0, itemData.effect.value);
        gameRef.hero.heal(healAmount);
        break;
      case 'dash_cooldown_multiplier':
        // Apply ability cooldown reduction
        gameRef.hero.abilityCooldownMultiplier *= itemData.effect.value;
        break;
      case 'max_health_increase':
        gameRef.hero.maxHealth += itemData.effect.value;
        gameRef.hero.health += itemData.effect.value;
        break;
      case 'attack_speed_multiplier':
        gameRef.hero.attackSpeedMultiplier += itemData.effect.value;
        break;
      case 'speed_multiplier':
        gameRef.hero.speedMultiplier += itemData.effect.value;
        break;
      case 'range_multiplier':
        gameRef.hero.rangeMultiplier += itemData.effect.value;
        break;
      // New stackable passive effects
      case 'projectile_count':
      case 'projectile_bounces':
      case 'projectile_size':
      case 'life_steal':
      case 'shield_hp':
      case 'coin_multiplier':
      case 'heal_per_kill':
      case 'crit_chance':
      case 'clone_spawn':
      case 'max_health_boost':
        final maxStacks = itemData.effect.maxStacks ?? 1;
        gameRef.hero.addPassiveEffect(itemData.effect.type, maxStacks);
        // Max health boost only affects max HP, not current HP
        break;
      case 'drone_count':
        final maxStacks = itemData.effect.maxStacks ?? 1;
        gameRef.hero.addPassiveEffect(itemData.effect.type, maxStacks);
        // Update drone count immediately
        gameRef.hero.updateDroneCount();
        break;
      case 'auto_injector':
        final maxStacks = itemData.effect.maxStacks ?? 1;
        gameRef.hero.addPassiveEffect(itemData.effect.type, maxStacks);
        // Auto-injector HP bonus is applied on kill, not on purchase
        break;
      case 'enlarged_caliber':
        final maxStacks = itemData.effect.maxStacks ?? 1;
        gameRef.hero.addPassiveEffect(itemData.effect.type, maxStacks);
        // Update hero size immediately
        gameRef.hero.updateHeroSize();
        break;
      default:
        print('Unknown item effect type: ${itemData.effect.type}');
    }
  }
  
  void onItemPurchased() {
    // Update roll button text based on remaining items
    final allItemsSold = itemSlots.every((slot) => slot.currentItem == null);
    final baseCost = WaveConfig.instance.shopConfig?.rollCost ?? 10;
    final rollCost = allItemsSold ? 0 : (baseCost + rollCount);
    rollButtonText.text = rollCost == 0 ? 'REROLL (FREE)' : 'REROLL ($rollCost)';
    
    // Update affordability of remaining items after purchase
    for (final slot in itemSlots) {
      if (slot.currentItem != null) {
        slot.updateAffordability();
      }
    }
  }
  
  void resetForNewWave() {
    rollCount = 0; // Reset roll count for new shop session
  }
  
  void closeShop() {
    hide();
    gameRef.onShopClosed();
  }
}

class ShopSlot extends RectangleComponent with TapCallbacks, HasGameRef<CircleRougeGame> {
  late TextBoxComponent nameText;
  late TextComponent costText;
  late TextComponent descriptionText;
  late RectangleComponent buyButton;
  late TextComponent buyButtonText;
  late Component itemIcon;
  late RectangleComponent border;
  late RectangleComponent outerGlow;
  late RectangleComponent buyButtonGlow;
  
  ShopItem? currentItem;
  
  ShopSlot({required Vector2 position}) : super(
    size: Vector2(ShopPanel.baseSlotWidth, ShopPanel.baseSlotHeight),
    paint: Paint()..color = Colors.transparent,
    position: position,
  );
  
  @override
  Future<void> onLoad() async {
    super.onLoad();
    
    // Background with enhanced gradient
    final background = RectangleComponent(
      size: Vector2(size.x, size.y),
      paint: Paint()
        ..shader = const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFF3A3A3A),
            Color(0xFF2A2A2A),
            Color(0xFF1A1A1A),
          ],
        ).createShader(Rect.fromLTWH(0, 0, size.x, size.y)),
      position: Vector2.zero(),
    );
    add(background);
    
    // Border with enhanced glow
    border = RectangleComponent(
      size: Vector2(size.x, size.y),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2
        ..color = const Color(0xFF4A9EFF).withOpacity(0.5),
      position: Vector2.zero(),
    );
    add(border);
    
    // Outer glow effect for slots
    outerGlow = RectangleComponent(
      size: Vector2(size.x + 4, size.y + 4),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 6
        ..color = const Color(0xFF4A9EFF).withOpacity(0.1)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 10),
      position: Vector2(-2, -2),
    );
    add(outerGlow);
    
    // Initialize item icon as empty placeholder - will be replaced when item is set
    itemIcon = RectangleComponent(
      size: Vector2(44, 44),
      position: Vector2((size.x - 44) / 2, 22),
      paint: Paint()..color = Colors.transparent,
    );
    add(itemIcon);
    
    // Item name with enhanced styling and line wrapping
    nameText = TextBoxComponent(
      text: '',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFF4A9EFF),
          fontSize: 17.6,
          fontWeight: FontWeight.w900,
          letterSpacing: 1,
          shadows: [
            Shadow(
              color: Color(0xFF4A9EFF),
              blurRadius: 6,
            ),
          ],
        ),
      ),
      align: Anchor.center,
      boxConfig: TextBoxConfig(
        maxWidth: size.x - 10,
        timePerChar: 0.0,
      ),
      anchor: Anchor.topCenter,
      position: Vector2(size.x / 2, 82.5),
    );
    add(nameText);
    
    // Item description with better styling
    descriptionText = TextComponent(
      text: '',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFFE0E0E0),
          fontSize: 13.2,
          fontWeight: FontWeight.w500,
          height: 1.4,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 2,
            ),
          ],
        ),
      ),
      anchor: Anchor.topCenter,
      position: Vector2(size.x / 2, 132),
    );
    add(descriptionText);
    
    // Cost with enhanced styling
    costText = TextComponent(
      text: '',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFFFFEB3B),
          fontSize: 19.8,
          fontWeight: FontWeight.w900,
          letterSpacing: 1,
          shadows: [
            Shadow(
              color: Color(0xFFFFEB3B),
              blurRadius: 8,
            ),
            Shadow(
              color: Colors.black,
              blurRadius: 4,
            ),
          ],
        ),
      ),
      anchor: Anchor.topCenter,
      position: Vector2(size.x / 2, 170.5),
    );
    add(costText);
    
    // Buy button with enhanced gradient styling
    buyButton = RectangleComponent(
      size: Vector2(143, 44),
      paint: Paint()
        ..shader = const LinearGradient(
          colors: [
            Color(0xFF4CAF50),
            Color(0xFF388E3C),
          ],
        ).createShader(Rect.fromLTWH(0, 0, 143, 44)),
      position: Vector2((size.x - 143) / 2, size.y - 60.5),
    );
    add(buyButton);
    
    // Buy button glow effect
    buyButtonGlow = RectangleComponent(
      size: Vector2(143, 44),
      paint: Paint()
        ..color = Colors.transparent
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3
        ..color = const Color(0xFF4CAF50).withOpacity(0.5)
        ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 6),
      position: Vector2((size.x - 143) / 2, size.y - 60.5),
    );
    add(buyButtonGlow);
    
    buyButtonText = TextComponent(
      text: 'PURCHASE',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white,
          fontSize: 15.4,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.2,
          shadows: [
            Shadow(
              color: Colors.black,
              blurRadius: 4,
            ),
          ],
        ),
      ),
      anchor: Anchor.center,
      position: Vector2(71.5, 22),
    );
    buyButton.add(buyButtonText);
  }
  
  // Get category colors based on item type
  Map<String, Color> _getCategoryColors(String itemId) {
    // Get item data to check its type
    final itemData = ItemConfig.instance.getItemById(itemId);
    final itemType = itemData?.type ?? 'other';
    
    switch (itemType) {
      case 'health':
        // Green for health items
        return {
          'primary': const Color(0xFF4CAF50),
          'secondary': const Color(0xFF66BB6A),
          'glow': const Color(0xFF4CAF50),
        };
      case 'attack':
        // Red for attack items
        return {
          'primary': const Color(0xFFF44336),
          'secondary': const Color(0xFFE57373),
          'glow': const Color(0xFFF44336),
        };
      case 'ability':
        // Hero color for ability items
        final heroColor = gameRef.hero.heroData.color;
        return {
          'primary': heroColor,
          'secondary': heroColor.withOpacity(0.8),
          'glow': heroColor,
        };
      case 'other':
      default:
        // Blue for other items
        return {
          'primary': const Color(0xFF2196F3),
          'secondary': const Color(0xFF64B5F6),
          'glow': const Color(0xFF2196F3),
        };
    }
  }

  void setItem(ShopItem item) async {
    currentItem = item;
    final colors = _getCategoryColors(item.id);
    
    nameText.text = item.name.toUpperCase();
    descriptionText.text = item.description;
    costText.text = '${item.cost} COINS';
    
    // Replace the current icon with a sprite-based icon
    if (itemIcon.isMounted) {
      itemIcon.removeFromParent();
    }
    
    try {
      // Try to load the actual item icon sprite
      final sprite = await Sprite.load(item.icon);
      itemIcon = SpriteComponent(
        sprite: sprite,
        size: Vector2(44, 44),
        position: Vector2((size.x - 44) / 2, 22),
        anchor: Anchor.topLeft,
      );
    } catch (e) {
      print('Could not load item icon: ${item.icon}, using colored rectangle fallback');
      // Fallback to colored rectangle with category color
      itemIcon = RectangleComponent(
        size: Vector2(44, 44),
        position: Vector2((size.x - 44) / 2, 22),
        paint: Paint()..color = colors['primary']!,
      );
    }
    
    add(itemIcon);
    
    // Update name text color to match category
    nameText.textRenderer = TextPaint(
      style: TextStyle(
        color: colors['primary']!,
        fontSize: 17.6,
        fontWeight: FontWeight.w900,
        letterSpacing: 1,
        shadows: [
          Shadow(
            color: colors['glow']!,
            blurRadius: 6,
          ),
        ],
      ),
    );
    
    // Update cost text color to match category
    costText.textRenderer = TextPaint(
      style: TextStyle(
        color: colors['primary']!,
        fontSize: 19.8,
        fontWeight: FontWeight.w900,
        letterSpacing: 1,
        shadows: [
          Shadow(
            color: colors['glow']!,
            blurRadius: 8,
          ),
        ],
      ),
    );
    
    // Update border and glow colors to match category
    border.paint.color = colors['primary']!.withOpacity(0.6);
    outerGlow.paint.color = colors['glow']!.withOpacity(0.15);
    
    // Update buy button styling based on affordability and category
    if (gameRef.hero.coins >= item.cost) {
      // Update buy button gradient with category colors
      buyButton.paint.shader = LinearGradient(
        colors: [
          colors['primary']!,
          colors['secondary']!,
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = colors['glow']!.withOpacity(0.5);
      buyButtonText.text = 'PURCHASE';
    } else {
      // Grey for unaffordable items
      buyButton.paint.shader = const LinearGradient(
        colors: [
          Color(0xFF757575),
          Color(0xFF616161),
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = const Color(0xFF757575).withOpacity(0.3);
      buyButtonText.text = 'TOO EXPENSIVE';
      border.paint.color = const Color(0xFFF44336).withOpacity(0.4);
    }
  }
  
  @override
  bool onTapDown(TapDownEvent event) {
    if (currentItem == null) return false;
    
    final localPoint = event.localPosition;
    
    // Check if buy button was tapped
    if (buyButton.containsLocalPoint(localPoint - buyButton.position)) {
      attemptPurchase();
      return true;
    }
    
    // Check if item info area was tapped (anywhere except buy button)
    if (localPoint.y < buyButton.position.y) {
      showItemDetails();
      return true;
    }
    
    return false;
  }
  
  void showItemDetails() {
    if (currentItem == null) return;
    
    final detailCard = ItemDetailCard(
      item: currentItem!,
      onClose: () {
        // Detail card handles its own removal
      },
    );
    
    // Add to the game at a high priority to appear on top
    gameRef.add(detailCard);
    
    // Play UI sound effect
    // SoundManager().playUICardOpenSound();
  }
  
  void attemptPurchase() {
    if (currentItem == null) return;
    
    if (gameRef.hero.coins >= currentItem!.cost) {
      gameRef.hero.spendCoins(currentItem!.cost);
      currentItem!.onPurchase();
      
      // Play purchase sound effect
      SoundManager().playPurchaseSound();
      
      // Clear this slot with enhanced sold styling
      currentItem = null;
      nameText.text = 'SOLD';
      nameText.textRenderer = TextPaint(
        style: const TextStyle(
          color: Color(0xFF4CAF50),
          fontSize: 17.6,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.5,
          shadows: [
            Shadow(
              color: Color(0xFF4CAF50),
              blurRadius: 8,
            ),
            Shadow(
              color: Colors.black,
              blurRadius: 3,
            ),
          ],
        ),
      );
      descriptionText.text = 'Item purchased successfully!';
      descriptionText.textRenderer = TextPaint(
        style: const TextStyle(
          color: Color(0xFF4CAF50),
          fontSize: 13.2,
          fontWeight: FontWeight.w500,
          height: 1.4,
        ),
      );
      costText.text = '';
      
      // Update buy button to sold out styling
      buyButton.paint.shader = const LinearGradient(
        colors: [
          Color(0xFF757575),
          Color(0xFF616161),
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = const Color(0xFF757575).withOpacity(0.3);
      buyButtonText.text = 'SOLD OUT';
      
      // Update border and glow to success green
      border.paint.color = const Color(0xFF4CAF50).withOpacity(0.8);
      outerGlow.paint.color = const Color(0xFF4CAF50).withOpacity(0.2);
      
      // Clear the item icon - handle both SpriteComponent and RectangleComponent types
      if (itemIcon.isMounted) {
        itemIcon.removeFromParent();
      }
      
      // Add transparent placeholder
      itemIcon = RectangleComponent(
        size: Vector2(44, 44),
        position: Vector2((size.x - 44) / 2, 22),
        paint: Paint()..color = Colors.transparent,
      );
      add(itemIcon);
      
      // Update parent shop immediately
      if (parent is ShopPanel) {
        (parent as ShopPanel).onItemPurchased();
      }
    }
  }
  
  void updateAffordability() {
    if (currentItem == null) return;
    
    final colors = _getCategoryColors(currentItem!.id);
    
    // Update buy button styling based on current affordability
    if (gameRef.hero.coins >= currentItem!.cost) {
      // Update buy button gradient with category colors
      buyButton.paint.shader = LinearGradient(
        colors: [
          colors['primary']!,
          colors['secondary']!,
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = colors['glow']!.withOpacity(0.5);
      buyButtonText.text = 'PURCHASE';
      border.paint.color = colors['primary']!.withOpacity(0.6);
      
      // Update cost text color to match category when affordable
      costText.textRenderer = TextPaint(
        style: TextStyle(
          color: colors['primary']!,
          fontSize: 19.8,
          fontWeight: FontWeight.w900,
          letterSpacing: 1,
          shadows: [
            Shadow(
              color: colors['glow']!,
              blurRadius: 8,
            ),
          ],
        ),
      );
    } else {
      // Grey for unaffordable items
      buyButton.paint.shader = const LinearGradient(
        colors: [
          Color(0xFF757575),
          Color(0xFF616161),
        ],
      ).createShader(Rect.fromLTWH(0, 0, 143, 44));
      
      buyButtonGlow.paint.color = const Color(0xFF757575).withOpacity(0.3);
      buyButtonText.text = 'TOO EXPENSIVE';
      border.paint.color = const Color(0xFFF44336).withOpacity(0.4);
      
      // Update cost text color to red when unaffordable
      costText.textRenderer = TextPaint(
        style: const TextStyle(
          color: Color(0xFFF44336), // Red for unaffordable
          fontSize: 19.8,
          fontWeight: FontWeight.w900,
          letterSpacing: 1,
          shadows: [
            Shadow(
              color: Color(0xFFF44336),
              blurRadius: 8,
            ),
          ],
        ),
      );
    }
  }
} 
```

Now let me update the ItemDetailCard to make all text colors match the border color:

```dart
    // Cost text
    costText = TextComponent(
      text: '${item.cost} COINS',
      textRenderer: TextPaint(
        style: TextStyle(
          color: borderColor, // Match border color
          fontSize: 20,
          fontWeight: FontWeight.bold,
          shadows: [
            Shadow(
              color: borderColor.withOpacity(0.8),
              blurRadius: 6,
            ),
          ],
        ),
      ),
      position: Vector2(size.x / 2, 120),
      anchor: Anchor.center,
    );
    add(costText);
```

Let me read the file to get the exact content:

Now I can make the correct replacement:

```dart
import 'package:flame/components.dart';
import 'package:flame/events.dart';
import 'package:flutter/material.dart';

import '../../game/circle_rouge_game.dart';
import '../../config/display_config.dart';
import '../../config/item_config.dart';
import '../shop_panel.dart';

class ItemDetailCard extends RectangleComponent with HasGameRef<CircleRougeGame>, TapCallbacks {
  final ShopItem item;
  final VoidCallback onClose;
  
  // Visual components
  late RectangleComponent background;
  late RectangleComponent border;
  late TextComponent titleText;
  late TextComponent descriptionText;
  late TextComponent costText;
  late TextComponent stackInfoText;
  late TextComponent instructionText;
  
  // Animation properties
  double animationTime = 0.0;
  static const double animationDuration = 0.3;
  bool isClosing = false;
  
  ItemDetailCard({
    required this.item,
    required this.onClose,
  }) : super(
    anchor: Anchor.center,
  ) {
    final screenWidth = DisplayConfig.instance.settings?.windowWidth ?? 800.0;
    final screenHeight = DisplayConfig.instance.settings?.windowHeight ?? 600.0;
    
    // Card dimensions
    final cardWidth = (screenWidth * 0.6).clamp(300.0, 500.0);
    final cardHeight = (screenHeight * 0.4).clamp(200.0, 300.0);
    
    size = Vector2(cardWidth, cardHeight);
    position = Vector2(screenWidth / 2, screenHeight / 2);
    
    _setupVisualComponents();
  }
  
  void _setupVisualComponents() {
    // Background with semi-transparent overlay
    background = RectangleComponent(
      size: size,
      paint: Paint()
        ..color = const Color(0xFF1A1A1A).withOpacity(0.95)
        ..style = PaintingStyle.fill,
    );
    add(background);
    
    // Border with item category color
    final borderColor = _getItemCategoryColor();
    border = RectangleComponent(
      size: size,
      paint: Paint()
        ..color = borderColor
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0,
    );
    add(border);
    
    // Title text
    titleText = TextComponent(
      text: item.name.toUpperCase(),
      textRenderer: TextPaint(
        style: TextStyle(
          color: borderColor,
          fontSize: 24,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.5,
        ),
      ),
      position: Vector2(size.x / 2, 40),
      anchor: Anchor.center,
    );
    add(titleText);
    
    // Cost text
    costText = TextComponent(
      text: '${item.cost} COINS',
      textRenderer: TextPaint(
        style: TextStyle(
          color: borderColor, // Match border color
          fontSize: 20,
          fontWeight: FontWeight.bold,
          shadows: [
            Shadow(
              color: borderColor.withOpacity(0.8),
              blurRadius: 6,
            ),
          ],
        ),
      ),
      position: Vector2(size.x / 2, 70),
      anchor: Anchor.center,
    );
    add(costText);
    
    // Description text (word-wrapped)
    final wrappedDescription = _wrapText(item.description, 45);
    descriptionText = TextComponent(
      text: wrappedDescription,
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Colors.white,
          fontSize: 16,
          height: 1.4,
        ),
      ),
      position: Vector2(size.x / 2, 110),
      anchor: Anchor.center,
    );
    add(descriptionText);
    
    // Stack information (if applicable)
    final stackInfo = _getStackInfo();
    if (stackInfo.isNotEmpty) {
      stackInfoText = TextComponent(
        text: stackInfo,
        textRenderer: TextPaint(
          style: const TextStyle(
            color: Color(0xFF88FF88), // Light green
            fontSize: 14,
            fontStyle: FontStyle.italic,
          ),
        ),
        position: Vector2(size.x / 2, size.y - 70),
        anchor: Anchor.center,
      );
      add(stackInfoText);
    }
    
    // Instruction text
    instructionText = TextComponent(
      text: 'TAP ANYWHERE TO CLOSE',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFF888888),
          fontSize: 12,
          letterSpacing: 1.0,
        ),
      ),
      position: Vector2(size.x / 2, size.y - 30),
      anchor: Anchor.center,
    );
    add(instructionText);
  }
  
  Color _getItemCategoryColor() {
    // Get item data to check its type
    final itemData = ItemConfig.instance.getItemById(item.id);
    final itemType = itemData?.type ?? 'other';
    
    // Determine color based on item type
    switch (itemType) {
      case 'health':
        return const Color(0xFF4CAF50); // Green
      case 'attack':
        return const Color(0xFFF44336); // Red
      case 'ability':
        // Use hero color for ability items
        return gameRef.hero.heroData.color;
      case 'other':
      default:
        return const Color(0xFF2196F3); // Blue
    }
  }
  
  String _getStackInfo() {
    final hero = gameRef.hero;
    
    switch (item.id) {
      case 'spread_master':
        final current = hero.getPassiveEffectStacks('projectile_count');
        return 'Current: +$current projectiles (Max: +9)';
      
      case 'bouncing_bullets':
        final current = hero.getPassiveEffectStacks('projectile_bounces');
        return 'Current: +$current bounces (Max: +3)';
      
      case 'drone_wingman':
        final current = hero.getPassiveEffectStacks('drone_count');
        return 'Current: $current drones (Max: 3)';
      
      case 'enlarged_caliber':
        final current = hero.getPassiveEffectStacks('projectile_size');
        final percentage = (current * 10);
        return 'Current: +$percentage% size (Max: +100%)';
      
      case 'vampiric_coating':
        final current = hero.getPassiveEffectStacks('life_steal');
        final percentage = (current * 5);
        return 'Current: +$percentage% life steal (Max: +20%)';
      
      case 'armor_plating':
        final current = hero.getPassiveEffectStacks('shield_hp');
        final shieldHP = current * 5;
        return 'Current: +$shieldHP shield HP (Max: +100)';
      
      case 'coin_magnet':
        final current = hero.getPassiveEffectStacks('coin_multiplier');
        final percentage = (current * 20);
        return 'Current: +$percentage% coin earn (Max: +100%)';
      
      case 'auto_injector':
        final current = hero.getPassiveEffectStacks('heal_per_kill');
        final healAmount = current * 2;
        return 'Current: +$healAmount HP per kill (Max: +10)';
      
      case 'critical_striker':
        final current = hero.getPassiveEffectStacks('crit_chance');
        final percentage = (current * 2);
        return 'Current: +$percentage% crit chance (Max: +10%)';
      
      case 'clone_projection':
        final hasClone = hero.hasCloneProjection;
        return hasClone ? 'Clone Projection: Available (Press C)' : 'Not owned';
      
      default:
        return '';
    }
  }
  
  String _wrapText(String text, int maxLineLength) {
    final words = text.split(' ');
    final lines = <String>[];
    String currentLine = '';
    
    for (final word in words) {
      if (currentLine.isEmpty) {
        currentLine = word;
      } else if ((currentLine + ' ' + word).length <= maxLineLength) {
        currentLine += ' ' + word;
      } else {
        lines.add(currentLine);
        currentLine = word;
      }
    }
    
    if (currentLine.isNotEmpty) {
      lines.add(currentLine);
    }
    
    return lines.join('\n');
  }
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Handle animation
    if (!isClosing) {
      animationTime += dt;
      if (animationTime < animationDuration) {
        final progress = animationTime / animationDuration;
        final easeProgress = _easeOutCubic(progress);
        
        // Scale animation
        scale = Vector2.all(easeProgress);
        
        // Fade in
        final opacity = easeProgress;
        background.paint.color = const Color(0xFF1A1A1A).withOpacity(0.95 * opacity);
        border.paint.color = _getItemCategoryColor().withOpacity(opacity);
      } else {
        scale = Vector2.all(1.0);
      }
    } else {
      animationTime -= dt * 3; // Faster closing animation
      if (animationTime <= 0) {
        removeFromParent();
        return;
      }
      
      final progress = animationTime / animationDuration;
      scale = Vector2.all(progress);
      
      // Fade out
      final opacity = progress;
      background.paint.color = const Color(0xFF1A1A1A).withOpacity(0.95 * opacity);
      border.paint.color = _getItemCategoryColor().withOpacity(opacity);
    }
  }
  
  double _easeOutCubic(double t) {
    return 1 - pow(1 - t, 3);
  }
  
  @override
  bool onTapDown(TapDownEvent event) {
    close();
    return true;
  }
  
  void close() {
    if (!isClosing) {
      isClosing = true;
      onClose();
    }
  }
  
  double pow(double base, int exponent) {
    double result = 1.0;
    for (int i = 0; i < exponent; i++) {
      result *= base;
    }
    return result;
  }
}

```

Now let me also update the description text to have a subtle tint that matches the border color:

```dart
import 'package:flame/components.dart';
import 'package:flame/events.dart';
import 'package:flutter/material.dart';

import '../../game/circle_rouge_game.dart';
import '../../config/display_config.dart';
import '../../config/item_config.dart';
import '../shop_panel.dart';

class ItemDetailCard extends RectangleComponent with HasGameRef<CircleRougeGame>, TapCallbacks {
  final ShopItem item;
  final VoidCallback onClose;
  
  // Visual components
  late RectangleComponent background;
  late RectangleComponent border;
  late TextComponent titleText;
  late TextComponent descriptionText;
  late TextComponent costText;
  late TextComponent stackInfoText;
  late TextComponent instructionText;
  
  // Animation properties
  double animationTime = 0.0;
  static const double animationDuration = 0.3;
  bool isClosing = false;
  
  ItemDetailCard({
    required this.item,
    required this.onClose,
  }) : super(
    anchor: Anchor.center,
  ) {
    final screenWidth = DisplayConfig.instance.settings?.windowWidth ?? 800.0;
    final screenHeight = DisplayConfig.instance.settings?.windowHeight ?? 600.0;
    
    // Card dimensions
    final cardWidth = (screenWidth * 0.6).clamp(300.0, 500.0);
    final cardHeight = (screenHeight * 0.4).clamp(200.0, 300.0);
    
    size = Vector2(cardWidth, cardHeight);
    position = Vector2(screenWidth / 2, screenHeight / 2);
    
    _setupVisualComponents();
  }
  
  void _setupVisualComponents() {
    // Background with semi-transparent overlay
    background = RectangleComponent(
      size: size,
      paint: Paint()
        ..color = const Color(0xFF1A1A1A).withOpacity(0.95)
        ..style = PaintingStyle.fill,
    );
    add(background);
    
    // Border with item category color
    final borderColor = _getItemCategoryColor();
    border = RectangleComponent(
      size: size,
      paint: Paint()
        ..color = borderColor
        ..style = PaintingStyle.stroke
        ..strokeWidth = 3.0,
    );
    add(border);
    
    // Title text
    titleText = TextComponent(
      text: item.name.toUpperCase(),
      textRenderer: TextPaint(
        style: TextStyle(
          color: borderColor,
          fontSize: 24,
          fontWeight: FontWeight.w900,
          letterSpacing: 1.5,
        ),
      ),
      position: Vector2(size.x / 2, 40),
      anchor: Anchor.center,
    );
    add(titleText);
    
    // Cost text
    costText = TextComponent(
      text: '${item.cost} COINS',
      textRenderer: TextPaint(
        style: TextStyle(
          color: borderColor, // Match border color
          fontSize: 20,
          fontWeight: FontWeight.bold,
          shadows: [
            Shadow(
              color: borderColor.withOpacity(0.8),
              blurRadius: 6,
            ),
          ],
        ),
      ),
      position: Vector2(size.x / 2, 70),
      anchor: Anchor.center,
    );
    add(costText);
    
    // Description text (word-wrapped)
    final wrappedDescription = _wrapText(item.description, 45);
    descriptionText = TextComponent(
      text: wrappedDescription,
      textRenderer: TextPaint(
        style: TextStyle(
          color: Color.lerp(Colors.white, borderColor, 0.3) ?? Colors.white, // Subtle tint matching border
          fontSize: 16,
          height: 1.4,
        ),
      ),
      position: Vector2(size.x / 2, 110),
      anchor: Anchor.center,
    );
    add(descriptionText);
    
    // Stack information (if applicable)
    final stackInfo = _getStackInfo();
    if (stackInfo.isNotEmpty) {
      stackInfoText = TextComponent(
        text: stackInfo,
        textRenderer: TextPaint(
          style: const TextStyle(
            color: Color(0xFF88FF88), // Light green
            fontSize: 14,
            fontStyle: FontStyle.italic,
          ),
        ),
        position: Vector2(size.x / 2, size.y - 70),
        anchor: Anchor.center,
      );
      add(stackInfoText);
    }
    
    // Instruction text
    instructionText = TextComponent(
      text: 'TAP ANYWHERE TO CLOSE',
      textRenderer: TextPaint(
        style: const TextStyle(
          color: Color(0xFF888888),
          fontSize: 12,
          letterSpacing: 1.0,
        ),
      ),
      position: Vector2(size.x / 2, size.y - 30),
      anchor: Anchor.center,
    );
    add(instructionText);
  }
  
  Color _getItemCategoryColor() {
    // Get item data to check its type
    final itemData = ItemConfig.instance.getItemById(item.id);
    final itemType = itemData?.type ?? 'other';
    
    // Determine color based on item type
    switch (itemType) {
      case 'health':
        return const Color(0xFF4CAF50); // Green
      case 'attack':
        return const Color(0xFFF44336); // Red
      case 'ability':
        // Use hero color for ability items
        return gameRef.hero.heroData.color;
      case 'other':
      default:
        return const Color(0xFF2196F3); // Blue
    }
  }
  
  String _getStackInfo() {
    final hero = gameRef.hero;
    
    switch (item.id) {
      case 'spread_master':
        final current = hero.getPassiveEffectStacks('projectile_count');
        return 'Current: +$current projectiles (Max: +9)';
      
      case 'bouncing_bullets':
        final current = hero.getPassiveEffectStacks('projectile_bounces');
        return 'Current: +$current bounces (Max: +3)';
      
      case 'drone_wingman':
        final current = hero.getPassiveEffectStacks('drone_count');
        return 'Current: $current drones (Max: 3)';
      
      case 'enlarged_caliber':
        final current = hero.getPassiveEffectStacks('projectile_size');
        final percentage = (current * 10);
        return 'Current: +$percentage% size (Max: +100%)';
      
      case 'vampiric_coating':
        final current = hero.getPassiveEffectStacks('life_steal');
        final percentage = (current * 5);
        return 'Current: +$percentage% life steal (Max: +20%)';
      
      case 'armor_plating':
        final current = hero.getPassiveEffectStacks('shield_hp');
        final shieldHP = current * 5;
        return 'Current: +$shieldHP shield HP (Max: +100)';
      
      case 'coin_magnet':
        final current = hero.getPassiveEffectStacks('coin_multiplier');
        final percentage = (current * 20);
        return 'Current: +$percentage% coin earn (Max: +100%)';
      
      case 'auto_injector':
        final current = hero.getPassiveEffectStacks('heal_per_kill');
        final healAmount = current * 2;
        return 'Current: +$healAmount HP per kill (Max: +10)';
      
      case 'critical_striker':
        final current = hero.getPassiveEffectStacks('crit_chance');
        final percentage = (current * 2);
        return 'Current: +$percentage% crit chance (Max: +10%)';
      
      case 'clone_projection':
        final hasClone = hero.hasCloneProjection;
        return hasClone ? 'Clone Projection: Available (Press C)' : 'Not owned';
      
      default:
        return '';
    }
  }
  
  String _wrapText(String text, int maxLineLength) {
    final words = text.split(' ');
    final lines = <String>[];
    String currentLine = '';
    
    for (final word in words) {
      if (currentLine.isEmpty) {
        currentLine = word;
      } else if ((currentLine + ' ' + word).length <= maxLineLength) {
        currentLine += ' ' + word;
      } else {
        lines.add(currentLine);
        currentLine = word;
      }
    }
    
    if (currentLine.isNotEmpty) {
      lines.add(currentLine);
    }
    
    return lines.join('\n');
  }
  
  @override
  void update(double dt) {
    super.update(dt);
    
    // Handle animation
    if (!isClosing) {
      animationTime += dt;
      if (animationTime < animationDuration) {
        final progress = animationTime / animationDuration;
        final easeProgress = _easeOutCubic(progress);
        
        // Scale animation
        scale = Vector2.all(easeProgress);
        
        // Fade in
        final opacity = easeProgress;
        background.paint.color = const Color(0xFF1A1A1A).withOpacity(0.95 * opacity);
        border.paint.color = _getItemCategoryColor().withOpacity(opacity);
      } else {
        scale = Vector2.all(1.0);
      }
    } else {
      animationTime -= dt * 3; // Faster closing animation
      if (animationTime <= 0) {
        removeFromParent();
        return;
      }
      
      final progress = animationTime / animationDuration;
      scale = Vector2.all(progress);
      
      // Fade out
      final opacity = progress;
      background.paint.color = const Color(0xFF1A1A1A).withOpacity(0.95 * opacity);
      border.paint.color = _getItemCategoryColor().withOpacity(opacity);
    }
  }
  
  double _easeOutCubic(double t) {
    return 1 - pow(1 - t, 3);
  }
  
  @override
  bool onTapDown(TapDownEvent event) {
    close();
    return true;
  }
  
  void close() {
    if (!isClosing) {
      isClosing = true;
      onClose();
    }
  }
  
  double pow(double base, int exponent) {
    double result = 1.0;
    for (int i = 0; i < exponent; i++) {
      result *= base;
    }
    return result;
  }
}

```

Now let me mark the todo as completed and check for linter errors:

Perfect! Let me provide a summary of the changes I made to ensure item text colors follow the border colors:

## â Updated Item Text Colors to Match Borders

### Shop Panel (`lib/components/shop_panel.dart`)

**Updated Text Components:**
1. **Item Name**: â Already matched border color
2. **Item Cost**: â Now matches border color with category-specific styling
3. **Item Description**: Kept neutral grey (good contrast for readability)

**Specific Changes:**
- **Cost Text Color**: Now dynamically uses `colors['primary']` with matching glow shadows
- **Affordability Logic**: 
  - **Affordable items**: Cost text matches category color (green/red/blue/hero color)
  - **Unaffordable items**: Cost text turns red to indicate cannot purchase
- **Enhanced Shadows**: Added glow effects that match the category color

### Item Detail Card (`lib/components/ui/item_detail_card.dart`)

**Updated Text Components:**
1. **Title Text**: â Already matched border color  
2. **Cost Text**: â Now matches border color instead of gold
3. **Description Text**: â Now has subtle tint matching border color (30% blend)
4. **Stack Info**: Kept green (functional color for stack information)
5. **Instruction Text**: Kept neutral grey (functional text)

**Specific Changes:**
- **Cost Text**: Changed from gold (`#FFD700`) to dynamic `borderColor` with shadows
- **Description Text**: Uses `Color.lerp(Colors.white, borderColor, 0.3)` for subtle tinting
- **Enhanced Shadows**: Added glow effects matching the border color

### Color Behavior by Item Type:

- **Health Items** (`health` type): ð¢ **Green** text and borders
- **Attack Items** (`attack` type): ð´ **Red** text and borders  
- **Ability Items** (`ability` type): ð¨ **Hero Color** text and borders (dynamic)
- **Other Items** (`other` type): ðµ **Blue** text and borders

### Visual Consistency:

Now all item interfaces maintain consistent color theming:
- **Border color** = **Primary text color** (name, cost)
- **Glow effects** match the category color
- **Description text** has subtle category tinting for cohesion
- **Unaffordable items** override with red cost text for clarity

This creates a much more cohesive and visually organized shop experience where players can immediately identify item categories by color, and all text elements reinforce the same color theme as the borders.

